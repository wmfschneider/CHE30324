#+BEGIN_HEADER
#+AUTHOR: William F. Schneider
#+TITLE: CHE 30324 Outline
#+EMAIL: wschneider@nd.edu
#+LATEX_CLASS_OPTIONS: [11pt]
#+LATEX_HEADER:\usepackage{geometry}
#+LATEX_HEADER:\geometry{margin=1.0in}
#+LATEX_HEADER:\usepackage{outline}
#+LATEX_HEADER:\usepackage{float}
#+LATEX_HEADER:\usepackage{amsmath}
#+LATEX_HEADER:\usepackage{tabu}
#+LATEX_HEADER:\usepackage{graphicx}
#+LATEX_HEADER:\usepackage{epstopdf}
#+LATEX_HEADER:\usepackage{siunitx}
#+LATEX_HEADER:\usepackage{fancyhdr}
#+LATEX_HEADER:\usepackage{hyperref}
#+LATEX_HEADER:\usepackage[labelfont=bf]{caption}
#+LATEX_HEADER:\setlength{\headheight}{15.2pt}
#+LATEX_HEADER:\def\dbar{{\mathchar'26\mkern-12mu d}}
#+LATEX_HEADER:\pagestyle{fancy}
#+LATEX_HEADER:\fancyhf{}
#+LATEX_HEADER:\renewcommand{\headrulewidth}{0.5pt}
#+LATEX_HEADER:\renewcommand{\footrulewidth}{0.5pt}
#+LATEX_HEADER:\lfoot{\today}
#+LATEX_HEADER:\cfoot{\copyright\ 2024 W.\ F.\ Schneider}
#+LATEX_HEADER:\rfoot{\thepage}
#+LATEX_HEADER:\lhead{\em{Physical Chemistry for Chemical Engineers}}
#+LATEX_HEADER:\rhead{ND CHE 30324}

#+OPTIONS: toc:2
#+OPTIONS: H:3 num:3
#+OPTIONS: ':t
#+END_HEADER


* The Classical Foundations
** Lecture 0: Introduction
1. Burning lighter
2. Foundations of Physical Chemistry
   1. Quantum mechanics
   2. Statistical mechanics
   3. Thermodynamics, kinetics, spectroscopy
   4. Physical and chemical properties of matter

#+BEGIN_EXPORT latex
\begin{table}
\begin{center}
\caption{Key units in Physical Chemistry}
\begin{tabular}{|lrlrl|} 
  \hline
  $N_\mathrm{Av}$: & $6.02214 \times 10^{23}$& mol$^{-1}$  & & \\
  1 amu: & $1.6605\times 10^{-27}$ & kg & & \\
  $k_\mathrm{B}$: & $1.38065\times 10^{-23}$ & J~K$^{-1}$ & $8.61734\times
  10^{-5}$ & eV K$^{-1}$\\
  $R$: & 8.314472 & J K$^{-1}$ mol$^{-1}$ & $8.2057 \times 10^{-2}$ & l atm mol$^{-1}$ K$^{-1}$\\
  $\sigma_\mathrm{SB}$: & $5.6704\times 10^{-8}$ & J s$^{-1}$ m$^{-2}$ K$^{-4}$ & & \\
  $c$: & $2.99792458\times 10^8$ & m s$^{-1}$ & & \\
  $h$: & $6.62607\times 10^{-34}$ & J s & $4.13566\times 10^{-15}$ & eV s
  \\
  $\hbar$: & $1.05457\times 10^{-34}$ & J s & $6.58212\times 10^{-16}$&  eV s \\
  $hc$: & 1239.8 & eV nm  & & \\
  $e$: & $1.60218\times 10^{-19}$ &  C & & \\
  $m_e:$ & $9.10938215\times 10^{-31}$ & kg &1:  0.5109989 & MeV c$^{-2}$  \\
  $\epsilon_0$: & $8.85419 \times 10^{-12}$ & C$^2$ J$^{-1}$ m$^{-1}$ & $5.52635\times
  10^{-3}$ & $e^2$ \AA$^{-1}$ eV$^{-1}$ \\
  $e^2/4\pi\epsilon_0$: & $2.30708 \times 10^{-28}$&  J m & 14.39964 & eV \AA\\
  $a_0$: & $0.529177 \times 10^{-10}$ & m & 0.529177 & \AA\\
  $E_\mathrm{H} $: & 1 & Ha & 27.212 & eV \\
  \hline
\end{tabular}
\end{center}
\end{table}
#+END_EXPORT
** Lecture 1: Basic statistics
*** Discrete probability distributions---Coin flip
   1. Example of Bernoulli trial, $2^n$ possible outcomes from $n$ flips
   2. Number of ways to get $i$ heads in $n$ flips, $_nC_i=n!/i!(n-i)!$
   3. Probability of $i$ heads $P_i \propto\ _nC_i$
   4. /Normalized/ probability, $\tilde P_i = P_i/\sum_i P_i =\ _nC_i/2^n$
   5. Expectation value $\langle i \rangle = \sum_i i \tilde P_i$

*** Continuous distributions---temperature
   1. Probability density $\phi(x)$ has units $1/x$
   2. Normalized $\tilde \phi(x) = \phi(x)/\int \phi(x) dx$
   3. (Unitless) probability $a < x < b = \int_a^b \tilde \phi(x) dx$
   4. Expectation value $\langle f(x) \rangle = \int f(x) \tilde \phi(x) dx$
   5. Mean $= \langle x \rangle$
   6. Mean squared $= \langle x^2 \rangle$
   7. Variance $\sigma^2=\langle x^2 \rangle - \langle x \rangle^2$
   8. Standard deviation $\Delta x = \sigma$

*** Temperature example
[[https://colab.research.google.com/github/wmfschneider/CHE30324/blob/master/Resources/Probability.ipynb]]

*** Boltzmann distribution
   1. $P(E) \propto e^{-E/k_BT}$, in some sense the definition of temperature (Figure 1)
   2. Energy and its units
   3. Absolute temperature and its units
   4. $k_BT$ as an energy scale, \SI{0.026}{eV} at \SI{298}{K}
   5. Equipartition -- energy freely exchanged within and between all degrees of freedom
*** Boltzmann distribution: Gravity example
      1. $E(h)=mgh$, linear, continuous energy spectrum
      2. Exponential distribution
         \[P(h) = \frac{1}{\int_0^\infty \exp\left(-mgh/k_BT\right)dh }\exp\left(\frac{-mgh}{k_BT}\right )  =  \frac{mg}{k_BT}\exp\left(\frac{-mgh}{k_BT}\right)\]
      3. molecule vs car in a gravitational field (Table ref:carvelectron)
      4. Implies exponential decrease in gas density with altitude
      5. Barometric law for gases, $P=P_0e^{-mgh/k_BT}$
*** Boltzmann distribution: Kinetic energy in 1-D example
      1. $KE = \frac{1}{2}m v_x^2$ , $P(v_x) \propto \exp \left (-m v_x^2/2 k_B T\right )$
      2. Standard Normalized Gaussian distribution of mean $\mu$ and variance $\sigma^2$
        \[G(x)=\frac{1}{\sigma\sqrt{2\pi}} \exp\left (
          -\frac{(x-\mu)^2}{2\sigma^2} \right )\] 
      3. By inspection, $\mu=\langle v_x \rangle=0$, $\sigma^2=\langle v_x^2\rangle =k_BT/m$
      4. Normalized velocity distribution
       \[P_{1D}(v_x) = \left ( \frac{m}{2\pi k_B T} \right )^{1/2}\exp\left
         (-\frac{m|v_x|^2}{2 k_BT} \right ) \]
      5. Molecule vs car again (Table  ref:carvelectron)

#+CAPTION: Car vs gas molecule at the earth's surface label:carvelectron 
|-------------------------------+-----------------------------+-----------------|
|                               | car                         | gas molecule    |
|-------------------------------+-----------------------------+-----------------|
| /m/                           | \SI{1000}{kg}               | \SI{1e-26}{kg}  |
| /h/                           | \SI{1}{m}                   | \SI{1}{m}       |
| /mgh/                         | \SI{9800}{J}                | \SI{9.8e-26}{J} |
|                               | \SI{6.1e22}{eV}             | \SI{6.1e-7}{eV} |
| /T/                           | \SI{298}{K}                 | \SI{298}{K}     |
| \(k_BT\)                      | \SI{0.026}{eV}              | \SI{0.026}{eV}  |
| \(mgh/k_BT\)                  | \SI{2.4e24}{}               | \SI{2.3e-5}{}   |
| \(P(\SI{1}{m})/P(0)\)         | \(e^{-2.4\times 10^{-24}}\) | 0.99998         |
| \(\langle h \rangle\)         | \SI{0}{m}                   | \SI{42}{km}     |
| \(\langle v_x \rangle^{1/2}\) | \SI{2e-12}{m/s}             | \SI{640}{m/s}   |
|-------------------------------+-----------------------------+-----------------|

#+BEGIN_EXPORT latex
\begin{table}\small
\begin{center}
\caption{Energy conversions and correspondences}
\begin{tabular}{|l|ccccc|}
\hline 
 & J & eV &  Hartree & kJ mol$^{-1}$ & cm$^{-1}$\\
\hline
1 J = & 1 & $6.2415\times 10^{18}$ & $2.2937\times 10^{17}$ &  $6.0221 \times
10^{20}$  & $5.0340 \times 10^{22} $\\ 
1 eV = & $1.6022 \times 10^{-19} $ & 1 & 0.036748 & 96.485 & 8065.5 \\
1 Ha = & $4.3598\times 10^{-18}$ & 27.212 & 1 & 2625.6 & 219474.6 \\
1 kJ mol$^{-1}$ = & $1.6605\times 10^{-21}$ & 0.010364 & $ 3.8087\times 10^{-4}$ & 1 & 83.5935 \\
1 cm$^{-1}$ = &$ 1.986410^{-23}$ & $1.23984\times 10^{-4}$ & $4.55623\times
10^{-6}$& 0.011963 & 1 \\
\hline 
\end{tabular}
\end{center}
\end{table}
#+END_EXPORT


#+BEGIN_SRC python :exports none :results output org drawer
import numpy as np
import matplotlib.pyplot as plt

R0 = 8.31441  # J/mol K
mass = 28. /1000 # kg/mol N2

def Boltzmann(E,T):
    return np.exp(-E/(R0*T))/(R0*T)

def MB1D(v,T):
    return np.sqrt(mass/(2*np.pi*R0*T))*np.exp(-(mass*v*v)/(2*R0*T))

def MB(c,T):
    K = 0.5 * mass * c *c
    degeneracy = 4 * np.pi * c * c
    normalization = (mass/(2*np.pi*R0*T))**1.5
    return normalization*degeneracy*Boltzmann(K,T)

energy = np.linspace(0,3000,1500)
velocity = np.linspace(-1000,1000,1000)
speed = np.linspace(0,1500,1000)

plt.figure()
for Temperature in [100,300,1000]:
   Probability = Boltzmann(energy,Temperature)
   plt.plot(Probability,energy,label='{0} K'.format(Temperature))

legend = plt.legend()

plt.ylabel('Energy (J/mol)')
plt.xlabel('Probability (mol/J)')
# plt.title('Boltzmann distribution at various temperatures')
plt.savefig('./Images/Boltzmann.png')

plt.figure()
for Temperature in [100,200,300,400,500]:
    Probability = MB1D(velocity,Temperature)
    plt.plot(velocity,Probability,label='{} K'.format(Temperature))

legend=plt.legend()
plt.xlabel('Velocity (m/s)')
plt.ylabel('Probability (1/(m/s))')
# plt.title('Boltzmann distribution at various temperatures')
plt.savefig('./Images/MB1D.png')

plt.figure()
for Temperature in [100,200,300,400,500]:
    Probability = MB(speed,Temperature)
    plt.plot(speed,Probability,label='{} K'.format(Temperature))

legend=plt.legend()
plt.xlabel('Speed (m/s)')
plt.ylabel('Probability (1/(m/s))')
# plt.title('Boltzmann distribution at various temperatures')
plt.savefig('./Images/MB.png')

#+END_SRC

#+RESULTS:
:results:
:end:

#+CAPTION: Boltzmann distribution at various temperatures
#+ATTR_LATEX: :width 0.5\textwidth
[[./Images/Boltzmann.png]]


#+CAPTION: One-dimensional (Gaussian) velocities of N$_2$ gas
#+ATTR_LATEX: :width 0.5\textwidth
[[./Images/MB1D.png]]

#+CAPTION: Maxwell-Boltzmann speed distribution of N$_2$ gas
#+ATTR_LATEX: :width 0.5\textwidth
[[./Images/MB.png]]

** Lecture 2: Kinetic theory of gases
1. Postulates
   1. Gas is composed of molecules in constant random, thermal motion
   2. Molecules only interact by perfectly elastic collisions
   3. Volume of molecules is $<<$ total volume
2. Maxwell-Boltzmann distribution of molecular speeds (Figure 3)
   1. Speed $v=\sqrt{v_x^2+v_y^2+v_z^2}$, spherical coordinates
     \begin{eqnarray*}   
       P_{\rm MB}(v) & = &\int\int P_{1D}(v_x) P_{1D}(v_y) P_{1D}(v_z) v^2 \sin(\theta) d\theta d\phi \\
         & = &4\pi v^2 \left( \frac{m}{2\pi k_B T}\right)^{3/2}\exp\left(-\frac{m
    v^2}{2k_B T}\right)
     \end{eqnarray*}
   2. mean speeds $\langle v \rangle = \int_0^{\infty} v P_{MB}(v)dv \propto \sqrt{T}$
   3. mean kinetic energy $\langle U \rangle = \frac{1}{2} m \langle v^2 \rangle =\frac{3}{2} RT$
   4. heat capacity $C_v= dU/dT = \frac{3}{2} R$
3. Flux and pressure
   1. Velocity flux $j(v_x) dv_x= v_x \frac{N}{V}P(v_x)dv_x$, molecules /area /time /$v_x$
   2. Wall collisions, $J_w = \int j(v_x) dv_x$, total collisions /area /time
   3. Momentum change with wall collisions ($\Delta$ momentum/area/time):
      \[ P = \int_0^\infty 2 m v_x j_x(v_x) dv_x = m (N/V) \langle v_x^2 \rangle = N k_B T/V \]
4. Collisions and mean free path
   1. Collision cross section $\sigma=\pi d^2$, area swept by molecule
   2. Molecular collisions per molecule = volume swept * density of targets = $z = \sigma \langle v \rangle (N/V) \sqrt{2}$
   3. Total collisions per volume = $z_{\mathrm{AA}} = z  (N/V) (1/2)$ 
   4. Mean free path, $\lambda = \langle v \rangle/z$ , mean distance between collisions

#+CAPTION: \ce{N2} at \SI{298}{K} and \SI{25}{\liter\per\mole}
|---------------------+----------------------------------------------------------|
| $\langle v \rangle$ | \SI{475}{\meter\per\second} = \SI{1060}{mph}             |
| $J_W$               | \SI{0.48}{\mole\per\centi\meter\squared\per\second}      |
| $P$                 | \SI{1}{bar}                                              |
| $\sigma$            | \SI{0.43}{nm^2}                                          |
| $z$                 | \SI{7e9}{\per\second}                                    |
| $Z_{\rm AA}$        | \SI{8e28}{\per\second\per\centi\meter\cubed}             |
| \lambda             | $\SI{68}{nm} = 183 \sigma$                               |
| $D_{11}$            | \SI{1.1e-5}{\meter\squared\per\second}                   |
|---------------------+----------------------------------------------------------|

#+BEGIN_EXPORT latex
\begin{table} 
\begin{center}
    \caption{Kinetic theory of gases key equations}
    \begin{tabular}{|lr|}
     \hline
 & \\
Boltzmann distribution & $\displaystyle P(E) = g(E) e^{-E/k_BT}$ \\ \ \ \ \ ($g(E)$: degeneracy of
$E$) & \\ 
Maxwell-Boltzmann distribution & $ \displaystyle
P_{\rm MB}(v) = 4\pi v^2 \left( \frac{m}{2\pi k_B T}\right)^{3/2}\exp\left(-\frac{m
    v^2}{2k_B T}\right) $ \\  & \\
Mean and RMS speeds & 

$\displaystyle \langle v \rangle = \left( \frac{8 k_B T}{\pi m} \right)^{1/2} \ \ \ \ \langle v^2
\rangle^{1/2} = \left( \frac{3 k_B T}{m} \right)^{1/2} $ \\  & \\

Pressure & $
\displaystyle \langle P \rangle = \frac{\Delta p}{\Delta t} = m \frac{N}{V}\frac{1}{3}\langle v^2
\rangle = \frac{N k_B T}{V}=\frac{n R T}{V} $ \\ & \\ 

Wall collision frequency &
$ \displaystyle  J_W = \frac{1}{4}\frac{N}{V}\langle v \rangle=\frac{P}{\left( 2 \pi m k_B
    T\right)^{1/2}} $ \\ & \\

Molecular collision frequency &
$ \displaystyle  z=\sqrt{2} \sigma \langle v \rangle\frac{N}{V} = \frac{4\sigma P}{\left( \pi m k_B T
  \right)^{1/2}} $ \\ & \\

Total collisions &
$ \displaystyle z_{AA} = \frac{1}{2} \frac{N}{V} z$ \\ & \\

Mean free path &
$\displaystyle \lambda = \frac{ \langle v \rangle}{z} = \frac{V}{\sqrt{2} \sigma N} $
\\ & \\

Graham's effusion law & $\displaystyle \frac{dN}{dt}=\text{Area}\cdot  J_w \propto 1/m^{1/2} $
\\ & \\

Self-diffusion constant &
$\displaystyle D_{11} = \frac{1}{3}\langle v \rangle \lambda $ \\ & \\

Diffusion rate &
$\displaystyle \langle x^2 \rangle^{1/2} = \sqrt{2 D t} $\ \ \ \  $\langle r^2 \rangle^{1/2} = \sqrt{6
D t}$ \\ & \\

Einstein-Smoluchowski equation & $\displaystyle D_{11}= \frac{\delta^2}{2\tau}$ \\ & \\

Stokes-Einstein equation for liquids & $\displaystyle D_{11}=\frac{k_BT}{4\pi\eta r}$\ \ \
``Slip'' boundary \\
 & \\
 & $\displaystyle D_\mathrm{Brownian}=\frac{k_BT}{6\pi\eta r}$\ \ \ ``Stick'' boundary \\
\hline
    \end{tabular}
\end{center}
 \end{table}
#+END_EXPORT

** Lecture 3: Transport
1. Transport of energy, momentum, mass across a gradient.
2. Infinite gradient: effusion and Graham's law, $\text{effusion rate}\propto MW^{-1/2}$
3. Finite gradient: Fick's first law 
   1. net flux proportional to concentration gradient
   2. $j_x = -D \frac{d c}{d x}$
   3. Self-diffusion constant, $D=\frac{1}{3}\lambda \langle v \rangle$
4. Fick's second law: time evolution of concentration gradient
   1. Continuity with no advection: \(\frac{\partial c}{\partial t}
          = -\nabla\cdot \vec{j} + \text{gen}\)
   2. One-dimension, point source: $\frac{d c}{d t} = D \frac{d^2 c}{dx^2}$, $c(x,t=0) =c_0$ 
   3. Separate variables $c(x,t) = X(x)t(t)$
   4. Diffusion has Gaussian probability distribution: \(c(x,t)/c_0 = [2 \sqrt{\pi D
          t}]^{-1} \exp(-x^2/4Dt)\)
5. Random walk model of diffusion
   1. $N$ steps, $n = n_r - n_l$ net to the right, $P(n) = \left ( \begin{smallmatrix}N \\ n_r \end{smallmatrix} \right )2^{-N}$
   2. Large $N$ and Stirling approximation, $N! \approx \left (2\pi N\right)^{1/2} N^N e^{-N}$
   3. Let $x = \delta (n_r - n_l)$, $N = t/\tau$, Gaussian reappears!
     \[ P(x,t) = \left ( \frac{2\tau}{\pi t}\right )^{1/2} e^{-x^2\tau/2t\delta^2} \]
   4. Einstein-Smoluchowski relation $D = \delta^2/2\tau$
6. Knudsen diffusion, $\delta = (3/2)l$, $\delta/\tau = \langle v \rangle$, $D=\frac{1}{3}l \langle v \rangle$
7. Seeing is believing---Brownian motion
   1. Seemingly random motion of large particles (``dust'') due to ``kicks'' from invisible molecules
   2. Einstein in one of his four 1905 /Annus Mirabilis/ [[https://einsteinpapers.press.princeton.edu/vol2-trans/137][papers]] shows
      1. Motion of particles suspened in a fluid of molecules must
         follow same Gaussian diffusion behavior
      2. From steady-state arguments in a field, diffusion constant is Boltzmann energy, $k_B T$, times mobility
      3. Mobility inversely related to viscosity
   3. Stokes-Einstein equation
   4. Allows measurement of Avogadro's number, final proof of kinetic theory of matter
   5. Similar model for diffusion of liquid molecules, slip boundary

#+BEGIN_SRC python :exports none :results output org drawer
import numpy as np
import matplotlib.pyplot as plt

R0 = 8.31441  # J/mol K
mass = 28. /1000 # kg/mol N2
sigma = 0.43e-18 # m^2
T = 298. # K
N = 6.022e23 # molecules
V = 25.e-3 # m^3

lambd = V/(N * sigma * np.sqrt(2))  # m

v = np.sqrt(8 * R0 * T/(np.pi *mass))  # m/s

D = (1./3.) * v * lambd # m^2/s, in 3-D
# print(D)

def conc(x,t):
    return 0.5*np.sqrt(1./(np.pi * D * t)) * np.exp(-x*x/(4*D*t))

distance = np.linspace(-1.,1.,200)

plt.figure()
for time in [1000,2000,3000,4000,5000]:
    distribution = conc(distance,time)
    plt.plot(distance,distribution,label='{} s'.format(time))

legend=plt.legend()
plt.xlabel('Distance (m)')
plt.ylabel('Probability (1/m)')
# plt.title('Boltzmann distribution at various temperatures')
plt.savefig('./Images/diffusion.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+CAPTION: Diffusional spreading, $\sqrt{\langle x^2 \rangle} = \sqrt{2 D t}$
#+ATTR_LATEX: :width 0.5\textwidth
[[./Images/diffusion.png]]

* Quantum Mechanics: Blurred Lines Between Particles and Waves
** Lecture 4: Duality and demise of classical physics
*** Heat capacities of solids
1. Heat energy stored in vibrations of atoms
   1. Hooke's Law in one dimension \(F=-kx\), \(V(x)=kx^2/2\), \(k =\) force constant
   2. Behave like harmonic oscillators
      1. Characteristic frequency \(\omega = \sqrt{\frac{k}{m}}\),  \(\nu =\omega/2\pi\)
      2. Position and speed:
\[ x(t) = A \sin \omega t,\ \dot{x}(t)= A \omega \cos \omega t \]
      3. Average energy in one dimension at temperature $T$:
\[ \langle E \rangle = \langle \frac{1}{2} m \dot{x}^2 \rangle + \langle \frac{1}{2}kx^2 \rangle = \frac{1}{2}RT+\frac{1}{2}RT =RT \]
   1. Law of DuLong and Pettite, $C_v = 3R$, fails at low $T$
   2. Einstein model
      1. Energy of atomic vibrations $\nu$ are /quantized/, $\epsilon_\nu=nh\nu$, $n = 0,1,2, \ldots$
      2. Expected energy of vibration
         \[\langle E \rangle_\nu = \sum_{n=0}^\infty nh\nu e^{-nh\nu/k_BT} = h\nu/\left (
          e^{h\nu/k_BT}-1 \right )\]
      4. Heat capacity = derivative of energy wrt temperature goes to zero at low $T$
*** Properties of waves
1. Characteristic of light, among other thing
2. Characterized by frequency, wavelength, amplitude, \ldots
3. Traveling waves, standing waves
4. Interference, diffraction
5. Expected energy of a classical wave, $\langle \epsilon \rangle _\nu = k_B T$ for all $\nu$

#+BEGIN_EXPORT latex
\begin{table}
\begin{center}
    \caption{Classical waves}
    \begin{tabular}{|lc|}
     \hline
The free wave equation & $\displaystyle \frac{ \partial^2 \Psi(x,t)}{\partial x^2} = \frac{1}{v^2}\frac{\partial^2 \Psi(x,t)}{\partial t^2}$ \\
\\
General solution & \(\Psi(x,t) = A \sin(kx -\omega t)\) \\
Wavenumber (1/distance) & \(k\) \\
Angular frequency (1/time) & \(\omega\) \\
Wavelength (distance) & \( \lambda = 2\pi/k \) \\
Frequency (/time) & \( \nu =\omega/2\pi \) \\
Speed (distance/time) & \( v= \lambda \nu \) \\
Amplitude (distance) & \(A\) \\
Energy & \( E \propto A^2 \) \\
Standing wave & \(\Psi(x,t) = A \sin(kx)\cos(\omega t), \quad k =n\pi/a\) \\
\hline
\end{tabular}
\end{center}
\end{table}
#+END_EXPORT

*** Blackbody radiation - light emitted by all bodies due to their temperature
1. Blackbody/Hohlraum spectrum (like the sun), box filled with light energy
   1. Stefan-Boltzmann law, total irradiance \(I(\lambda,T)\)
   2. Wien's displacement law, $\lambda_\mathrm{text}T = \mathrm{constant}$
2. Rayleigh-Jeans predicts \(I(\lambda,T)\) using classical physics
   1. standing waves + classical wave energy \(\rightarrow\) "ultraviolet catastrophe"
   2.   \(I(\lambda, T) = (8\pi/\lambda^4) \cdot k_B T \cdot c \)
3. Planck model, 1900
   1. Energy spectrum of waves are /quantized/, $\epsilon_\nu=nh\nu$, $n = 0,1,2, \ldots$
   2. Expected energy of a quantized wave: 
      \[\langle \epsilon \rangle_\nu = \sum_{n=0}^\infty nh\nu e^{-nh\nu/k_BT} = h\nu/\left (
          e^{h\nu/k_BT}-1 \right )\]
   3. Intensity:
      \[I(\lambda, T) = \frac{8\pi}{\lambda^4} \cdot \langle\epsilon \rangle_\nu \cdot c \]
   4. Correctly reproduces Stefan-Boltzmann and Wien Laws!
*** Photoelectric effect - electrons emitted when light shined on a metal
1. Energy of most weakly bound electrons to a material defined as work function, $W$
2. Shine light on metal, observe kinetic energy of electrons $E_\text{kinetic}=h\nu -W$
3. Kinetic energy varies with light frequency, number of electrons varies with light intensity
4. Einstein model, 1905 (Nobel prize)
   1. Light is both wave-like /and/ composed of particle-like "photons"
   2. Photon energy related to frequency: \(\epsilon = h \nu\ = hc/\lambda\)
   3. Light intensity related to number of photons
*** Special theory of relative (Einstein, 1905)
1. speed of light /c/ in a vacuum is a constant for all observes, independent of \(\nu\)
2. photons carry momentum  $p=h/\lambda$
3. demonstrated by Compton effect, light scattering off electrons changes $\lambda$
*** Rutherford, planetary model of atom
1. Inconsistent with Maxwell's equations
*** Bohr model of H atom
1. Bohr model (the old quantum mechanics)
   1. Stable electron "orbits," quantized angular momentum
   2. Light emission corresponds to orbital jumps, $\nu=\Delta E/h$
   3. Bohr equations
   4. Comparison with Rydberg formula
   5. Failure for larger atoms
2. Explains discrete H energy spectrum and Rydberg formala
*** de Broglie relation
1. $\lambda=h/p$ /universally/
2. Relation to Bohr orbits
3. Davison and Germer experiment, $e^-$ diffraction off Ni
4. Basis of modern electron diffraction to observe structure of materials
*** Wave-particle duality

#+BEGIN_SRC python :exports results :results output
import numpy as np
import matplotlib.pyplot as plt

hc = 1239.8      # eV nm
c = 2.9979e8 * 1.e9   # nm/s
k = 8.61734e-5   # eV /K
hck = hc/k       # nm K

def Irrad(wl,T):
      return (8. * np.pi * hc * c * wl**-5) / (np.exp(hck/(wl*T))-1)
def PlanckEnergy(wl,T):
      return (hc/wl) / (np.exp(hck/(wl*T))-1)

plt.figure()
wl=np.linspace(100,5000,1000)
for T in [1000.,2000.,3000.,4000.,5000.]:
    Intensity = Irrad(wl,T)
    plt.plot(wl,Intensity,label='{} K'.format(T))

legend=plt.legend()
plt.xlabel('Wavelength (nm)')
plt.ylabel('Irradiance (eV/nm$^3$/s)')
# plt.title('Boltzmann distribution at various temperatures')
plt.savefig('./Images/BlackBody.png')

plt.figure()
color=['red','orange','green','blue','violet']
wl=np.linspace(100,20000,1000)
for T in [1000.,2000.,3000.,4000.,5000.]:
    Energy = PlanckEnergy(wl,T)
    plt.plot(wl,Energy,label='{} K'.format(T),color=color[0])
    kT = k*T
    plt.plot([100,max(wl)],[kT,kT],ls='--',color=color.pop(0))

legend=plt.legend()
plt.xlabel('Wavelength (nm)')
plt.ylabel('Energy (eV)')
# plt.title('Boltzmann distribution at various temperatures')
plt.savefig('./Images/Planck.png')

#+END_SRC

#+RESULTS:

#+BEGIN_EXPORT LaTeX
\begin{table}
\caption{(left) Blackbody irradiance. (right) Average energy of a Planck quantized oscillator}
\begin{tabular}{cc}
\includegraphics[scale=0.52]{./Images/BlackBody.png} &
\includegraphics[scale=0.52]{./Images/Planck.png} 
\end{tabular}
\end{table}
#+END_EXPORT


#+BEGIN_EXPORT latex
\begin{table} 
\begin{center}
    \caption{The new physics}
    \begin{tabular}{|lr|}
     \hline
 & \\
Stefan-Boltzmann Law & $\displaystyle  \int I(\lambda,T)d\lambda = \sigma_\mathrm{SB} T^4$
\\ & \\
Wien's Law & $\displaystyle \lambda_\mathrm{max}T=2897768$ nm K \\
 & \\
Rayleigh-Jeans eq& $\displaystyle I(\lambda,T) = \frac{8\pi}{\lambda^4} k_B T c $ \\ 
& \\
Blackbody irradiance & $\displaystyle I(\lambda, T) =
\frac{8\pi}{\lambda^5}\frac{hc^2}{e^{hc/\lambda k_B T}-1}$ \\ 
& \\
Einstein crystal & $\displaystyle C_v=3R \left(\frac{h\nu}{k_BT}\right )^2\frac{e^{h\nu/k_BT}}{\left
            ( e^{h\nu/k_BT}-1 \right )^2}$ \\
& \\
Photon energy & $\displaystyle \epsilon=h\nu = hc/\lambda $ \\
& \\
Rydberg equation & $\displaystyle \nu = R_H c\left (1/n^2
        -1/k^2 \right)$ \\
& \\
Bohr equations & $\displaystyle l_n=n \hbar$ \\
$\displaystyle n=1,2, \ldots $ & $\displaystyle r_n = n^2 \left ( \frac{4 \pi
    \epsilon_0 \hbar^2}{e^2 m_e} \right ) = n^2 a_0$ \\
 & $\displaystyle E_n =-\frac{m_e e^4}{8\epsilon_0^2
   h^2}\frac{1}{n^2}=-\frac{E_H}{2}\frac{1}{n^2}$ \\ 
 & $\displaystyle p_n =\frac{e^2}{4\pi\epsilon_0}\frac{m_e}{\hbar}\frac{1}{n} =
p_0 \frac{1}{n} $ \\
& \\
de Broglie equation & $ \displaystyle \lambda=\dfrac{h}{p}$ \\
\hline
\end{tabular}
\end{center}
\end{table}
#+END_EXPORT

** Lecture 5: Postulates of quantum mechanics
*** Schr\ouml{}dinger equation describes wave-like properties of matter
1. Attempt to mathematically elaborate de'Broglie idea
2. Statement of conservation of energy, kinetic + potential = total
3. One-dimensional, time-independent, single particle Schr\ouml{}dinger equation:
    \[-\frac{\hbar^2}{2 m} \frac{d^2 \psi(x)}{dx^2} + V(x) \psi(x) = E \psi(x)\]
4. Second-order differential equation, solutions are steady-states of the system, discrete /eigenvalues/ $E$ and /eigenvectors/ $\psi(x)$
5. Applied to H atom by Schr\ouml{}dinger to recover Bohr energies
*** Born interpretation
1. wavefunction \(\psi(x)\) is a probability amplitude
2. wavefunction squared \(|\psi(x)|^2\) is probability density
*** Postulates
1. Wavefunction contains all information about a system
2. Operators used to extract that information
   1. QM operators are /Hermitian/
   2. Have eigenvectors and real eigenvalues, $\hat{O}\psi_i=o\psi_i$
   3. Are orthogonal, $\langle \psi_i | \psi_j \rangle = \delta_{ij}$
   4. Always observe an eigenvalue when making an observation
3. Expectation values
4. Energy-invariant wavefunctions given by Schr\ouml{}odinger equation
5. Uncertainty principle
*** Particle in a box illustrations

#+BEGIN_EXPORT latex
\begin{table} 
\begin{center}
    \caption{\large{Postulates of Non-relativistic Quantum Mechanics}}
   \begin{description}
    \item[Postulate 1:] {{\bf The physical state of a system is completely described by
        its wavefunction $\Psi$.}  In general, $\Psi$ is a complex function of the spatial
      coordinates and time.  $\Psi$ is required to be:}
    \begin{outline}
      \item{Single-valued}
      \item {continuous and twice differentiable}
      \item {square-integrable ($\int \Psi^*\Psi d\tau$ is defined over all finite domains)}
      \item {For bound systems, $\Psi$ can always be normalized such that $\int \Psi^*\Psi d\tau=1$}
    \end{outline}

  \item[Postulate 2:]  To every physical observable quantity $M$ there corresponds a
    Hermitian operator $\hat{M}$.  {\bf The only observable values of $M$ are the
      eignevalues of $\hat{M}$.}
    \begin{center}
    \begin{tabular}[H]{ccc}
      \hline
{\bf Physical quantity} & {\bf Operator} & {\bf Expression} \\
\hline
Position $x,y,z$ & $\hat{x},\hat{y},\hat{z}$ & $x\cdot, y\cdot, z\cdot$ \\ \\
Linear momentum $p_x, \ldots$ & $\hat{p}_x,\ldots $ & $\displaystyle -i\hbar\frac{\partial}{\partial
  x},\ldots $\\
Angular momentum $l_x, \ldots$ & $\hat{p}_x,\ldots $ & $\displaystyle -i\hbar \left
  (y\frac{\partial}{\partial z}-z\frac{\partial}{\partial y}\right ), \ldots $ \\
Kinetic energy $T$ & $\hat{T}$ & $\displaystyle -\frac{\hbar^2}{2m}\nabla^2$ \\
Potential energy $V$ & $\hat{V}$ & $V({\bf r},t)$ \\
Total energy $E$ & $\hat{H}$ & $\displaystyle -\frac{\hbar^2}{2m}\nabla^2+V({\bf r},t)$\\ \\
\hline
    \end{tabular}
  \end{center}
    \item[Postulate 3:] {If a particular observable $M$ is measured many times on many
      identical systems is a state $\Psi$, the average resuts with be the expectation
      value of the operator $\hat{M}$:
      \begin{equation*}
        \langle M \rangle = \int \Psi^* (\hat{M}\Psi)d{\bf\tau}
      \end{equation*}}
    \item[Postulate 4:] {The energy-invariant states of a system are solutions of the equation
        \begin{eqnarray*}
          \hat{H}\Psi({\bf r},t) & = & i\hbar\frac{\partial}{\partial t}\Psi({\bf r},t) \\
          \hat{H} & = & \hat{T}+\hat{V}
        \end{eqnarray*}
      The time-independent, stationary states of the system are solutions to the equation
      \begin{equation*}
        \hat{H}\Psi({\bf r}) = E\Psi(\bf{r})
      \end{equation*}
}
    \item[Postulate 5:] (The {\bf uncertainty principle}.)  Operators that do not commute
      $(\hat{A}(\hat{B}\Psi)\neq\hat{B}(\hat{A}\Psi))$ are called {\em conjugate}.
      Conjugate observables cannot be determined simultaneously to arbitrary accuracy.
      For example, the standard deviation in the measured positions and momenta of
      particles all described by the same $\Psi$ must satisfy $\Delta x\Delta p_x \geq \hbar/2$.
    \end{description}
\end{center}
\end{table}
#+END_EXPORT
** Lecture 6: Particle in a box model
*** Particle between infinite walls, electron confined in a wire
1. Classical solution, either stationary or uniform bouncing back and forth
*** One-dimesional QM solutions
1. Schr\ouml{}dinder equation and boundary conditions (Table 9)
2. discrete, quantized solutions
3. standing waves, $\lambda=2 L/n$, $n-1$ nodes, non-uniform probability
4. [[http://dx.doi.org/10.1021/jp053496l][Ho paper]], STM of Pd wire
5. zero point energy and uncertainty
6. correspondence principle
7. superpositions
*** Multiple dimensions
1. separation of variables, one quantum number for each dimension
2. \(\Psi_{lmn}(x,y,z) = \psi_l(x) \psi_m(y) \psi_n(z)\), [[https://colab.research.google.com/github/wmfschneider/CHE30324/blob/master/Resources/3dbox.ipynb][3dbox notebook]]
3. \(E_{lmn}=(l^2+m^2+n^2)\pi^2\hbar^2/2L^2 \longrightarrow\) /degeneracies/
*** Finite walls and tunneling
1. Potential well of finite depth $V_0$
2. Finite number of bound states
3. Classical region, $\psi(x) ~ e^{ikx}+e^{-ikx}, k=\sqrt{2mE}/\hbar$
4. "Forbidden" region, $\psi(x) ~ e^{\kappa x}+e^{-\kappa x},
      \kappa=\sqrt{2m(V_0-E)}/\hbar$
5. Non-zero probability to "tunnel" into forbidden region
6. Tunneling between two adjacent wells: chemical bonding, STM, nanoelectronics
7. H atom tunneling: NH$_3$ inversion, H transfer, kinetic isotope effect
*** Pauli principle for fermions

#+BEGIN_EXPORT latex
\begin{table}[tb]
   \begin{center}
   \caption{Particle-in-a-box model}
    \label{Particle-in-a-box}
\begin{tabular}[H]{|c|}
\hline
 \\
$\displaystyle       V(x) = \left \{
        \begin{array}{rl}
          0 & 0 < x < L \\
          \infty & x \leq 0 \text{ or } x \geq L
        \end{array} \right . $ \\
 \\
$\displaystyle     \psi_n(x) =\sqrt{\frac{2}{L}} \sin \left ( \frac{n\pi x}{L} \right )$
\\ \\
$\displaystyle \lambda_n = \frac{2 L}{n}$
 \\ \\
$\displaystyle     E_n =\frac{n^2\pi^2\hbar^2}{2mL^2}, n = 1, 2, ...$ \\
\\ \underline{Dipole Selection Rule} \\
$\displaystyle \Delta n = $ odd 
\\
     \includegraphics[scale=.5]{Images/PIAB.png} \\       
\hline
\end{tabular}
 \end{center}
\end{table}
#+END_EXPORT

#+BEGIN_SRC python :exports results :results output
import numpy as np
import matplotlib.pyplot as plt

hc = 1239.8      # eV nm
c = 2.9979e8 * 1.e9   # nm/s
k = 8.61734e-5   # eV /K
hck = hc/k       # nm K
me = 5.685630e-30  # eV/(nm/s)^2
hbar = 6.58212e-16 # eV s 

L = 1.0 ; # nm
E0 = (1./(2.*me))*(np.pi * hbar/L)**2  # eV

def psi(n,x):
      return np.sqrt(2./L)*np.sin(n*np.pi*x/L)
def eig(n):
      return E0*n*n

plt.figure()
wl=np.linspace(0,L,500)
for n in [1,2,3,4,5]:
    waveftn = psi(n,wl)
    energy = eig(n)
    plt.plot([0,L],[energy,energy],ls='--',color='black')
    offset = waveftn + energy
    plt.plot(wl,offset,label='n = {}'.format(n))

Legend=plt.legend()
plt.xlabel('Distance (L)')
plt.ylabel('Energy (eV)')
plt.title('Energies and wavefunctions of an electron confined to a 1 nm box')
plt.savefig('./Images/PIAB.png')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :exports results :results output
import plotly.graph_objects as go
import numpy as np

xmesh=[]
ymesh=[]
zmesh=[]

points=25

plans = [[1,1,1,'psi_s'],[1,1,2,'psi_p'],[1,2,2,'psi_d'],[2,2,2,'psi_f']]
save=plans

array=[[],[],[],[]]

# Loop to create mesh and populate array with function values
for z in np.linspace(0.,1.,points):
    for y in np.linspace(0.,1.,points):
        for x in np.linspace(0.,1.,points):
            xmesh.append(x)
            ymesh.append(y)
            zmesh.append(z)

            i=0
            for plan in plans:
                l=plan[0]; m=plan[1]; n=plan[2]
                value=np.sin(l*np.pi*x)*np.sin(m*np.pi*y)*np.sin(n*np.pi*z)
                array[i].append(value)
                i+=1

iso = 0.1

i=0
for plan in plans:
    fig= go.Figure(data=go.Isosurface(
        x=xmesh,
        y=ymesh,
        z=zmesh,
        value=array[i],
        isomin=-iso,
        isomax=iso,
        surface_count=2,
        opacity=0.5,
        showscale=False,
        caps=dict(x_show=False, y_show=False,z_show=False)
    ))

    fig.write_image('./Images/'+plan[3]+'.png')
    i+=1
#+END_SRC

#+RESULTS:

#+BEGIN_EXPORT LaTeX
\begin{table}
\caption{Three-dimensional particle-in-a-box s-like, p-like, d-like, and f-like wavefunctions}
\begin{tabular}{cc}
\includegraphics[scale=0.6]{./Images/psi_s.png} &
\includegraphics[scale=0.6]{./Images/psi_p.png} \\
\includegraphics[scale=0.6]{./Images/psi_d.png} &
\includegraphics[scale=0.6]{./Images/psi_f.png} \\
\end{tabular}
\end{table}
#+END_EXPORT

** Lecture 7: Harmonic oscillator
*** Classical harmonic oscillator
1. Hooke's law, $F=-k(x-x_0)$, $k$ spring constant
2. Continuous sinusoidal motion
3. $x(t)=A \sin(\frac{k}{\mu})^{1/2}t, \nu=\frac{1}{2\pi}(\frac{k}{\mu})^{1/2}, E=\frac{1}{2}kA^2$
4. Exchanging kinetic and potential energies
*** Quantum harmonic oscillator
1. Schr\ouml{}dinger equation and boundary conditions
2. Solutions like P-I-A-B + tunneling at boundaries (see Table 10)
3. Zero-point energy and uniform energy ladder
4. Parity operator and even/odd symmetry:  \(\langle x \rangle =0 \)
5. Recursion relations: \( \langle x^2 \rangle =
      \alpha^2 (v+1/2), \langle V(x) \rangle = \frac{1}{2} h\nu (v+\frac{1}{2})\)
6. Virial theorem: $V(x) \propto x^n \rightarrow \langle T \rangle = \frac{n}{2}\langle V \rangle$
7. Classical turning point and =tunneling=
8. Classical limiting behavior: large 
*** HCl example
1. Reduced mass, $\frac{1}{\mu}=\frac{1}{m_A}+\frac{1}{m_B}$
2. ZPE, energy spacing in IR, Boltzmann probabilities
*** Diatomic vibrational spectroscopy
1. Apply harmonic oscillator model
2. Vibrational constant $\tilde{\nu} = (\sqrt{k/\mu}/2\pi)/hc$ cm$^{-1}$
3. Gross selection rule: dynamic dipole $d\mu/dx$ non-zero (heteronuclear, non homonuclear)
4. Specific selection rule: dipole integral $\langle \psi_v|\hat\mu|\psi_{v^\prime} \rangle =0$
          unless $\Delta v = \pm 1$
5. Allowed $\Delta \tilde{E}_v = \tilde{\nu}$ cm$^{-1}$
6. Boltzmann distribution implies $v=0$ states dominate at normal $T$
*** Polyatomic vibrational spectroscopy
1. Polyatomics, $3n-6$ ($3n-5$ for linear polyatomic) vibrational modes
2. Selection rules and degeneracies affect number of observed features
3. CO$_2$ example

#+BEGIN_EXPORT latex
\begin{table}[]
   \begin{center}
   \caption{Harmonic oscillator model}
    \label{Harmonic-oscillator}
\begin{tabular}[H]{|c|}
\hline
 \\
$\displaystyle       V(x) = \frac{1}{2} k x^2, -\infty < x < \infty $ \\
 \\
$\displaystyle     \psi_v(x) = N_v H_v(x/\alpha)e^{-x^2/2\alpha^2}, v = 0, 1, 2, \ldots $ \\
\\
$\displaystyle \alpha=(\hbar^2/\mu k)^{1/4}, N_v=(2^vv!\alpha\sqrt{\pi})^{-1/2} $ \\
 \\
\underline{Hermite polynomials} \\
$\displaystyle H_0(y) =1$\\
$\displaystyle H_1(y) = 2y$\\
$\displaystyle H_2(y) = 4y^2-2$\\
$\displaystyle H_{n+1}(y) = 2 y H_n(y) -2 n H_{n-1}(y)$\\
 \\
$\displaystyle     \nu =\frac{1}{2\pi}\sqrt\frac{k}{\mu}$ \\
$\displaystyle     E_v=(v+\frac{1}{2})h \nu, v=0, 1, 2, ...$ \\

\\ \underline{Specific Selection Rule for Absorption} \\
$\displaystyle \Delta v = \pm 1$
 \\
 \\
     \includegraphics[scale=.6]{Images/HO} \\       
\hline
\end{tabular}
 \end{center}
\end{table}
#+END_EXPORT

#+BEGIN_SRC python :exports results :results output
# Stub to solve Schrodinger eq numerically
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
from scipy import linalg as LA

hc = 1239.8      # eV nm
c = 2.9979e8 * 1.e9   # nm/s
kB = 8.61734e-5   # eV /K
hckB = hc/kB       # nm K
me = 5.685630e-30  # eV/(nm/s)^2
hbar = 6.58212e-16 # eV s 
mH = 1.0364269572e-26 # eV/(nm/s)^2

# harmonic parameters
k = 800.0 *  6.24150912588 # eV / nm^2


def harmonic(k,x):
    return 0.5 * k * x**2

def Hmat(mass,V):
    hbar2mu = -hbar*hbar/(2 * mass) # eV nm^2
    n = np.size(V)
#    print(n)

    A = np.zeros((n-1,n-1))
    for i in range(n-1):
        for j in range(n-1):
            if i==j+1 or i==j-1:
                 A[i,j]=(3./2.)*hbar2mu
            if i==j+2 or i==j-2:
                 A[i,j]=-(3./20.)*hbar2mu
            if i==j+3 or i==j-3:
                 A[i,j]=(1./90.)*hbar2mu
        A[i,i]=-(49./18.)*hbar2mu #+V([i]) 
    return A

X = np.linspace(-0.01,0.01,100)
#print(X)
#print(np.size(X))
V = harmonic(k,X)
#print(V)
#print(np.size(V))
H = Hmat(mH,V)
#print(H)
# eigenE, eigenfn = LA.eigh(A)

# print(eigenE)

# plt.figure()
# plt.plot(X,V)
# plt.xlabel('Distance (nm)')
# plt.ylabel('Energy (eV)')

# plt.savefig('./Images/harmonic.png')


#+END_SRC

#+RESULTS:

#+BEGIN_COMMENT
#+BEGIN_SRC python :exports results
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
from scipy import linalg as LA

#
# Numerical solution of Schrodinger equation by finite difference
#


# Read potential energy file
X = np.loadtxt(r'real62.csv',delimiter=',',usecols=(0,))
E = np.loadtxt(r'real62.csv',delimiter=',',usecols=(1,))
E -=min(E)

eVolt = 1.60218e-19 # conversion factor from eV to J
heV = 4.135667662e-15 # Planck's constant in ev.s
A2M2 = 1e-20 # conversion factor from sq. Angstrom to sq m
mAds = 1.574528e-27 # mass of proton
c = 29979245800 # speed of light

# Calculate the kinetic energy cefficient
KE = heV*heV*eVolt/(8*np.pi**2*mAds*A2M2)

# Min and max for grid
xMin = min(X)
xMax = max(X)

# Fit a curve to X,E data
xnew = np.linspace(xMin,xMax,100)
V = interp1d(X,E, kind='cubic',bounds_error=False,fill_value='extrapolate')
# fig = plt.figure()
# ax = fig.add_subplot(1,1,1)
# ax.plot(xnew,V(xnew))
# plt.show()
plt.plot(xnew,V(xnew),color='b',label='Anharmonic')

# Solving the Schrodinger equation using finite difference
L = xMax +.5
n = 1000;
dx = 2*L/n
xGrid = np.arange(-L+dx,L,dx)
A = np.zeros((n-1,n-1))
for i in range(n-1):
    for j in range(n-1):
        if i==j+1 or i==j-1:
            A[i,j]=-3/2*KE/dx**2
        if i==j+2 or i==j-2:
            A[i,j]=3/20*KE/dx**2
        if i==j+3 or i==j-3:
            A[i,j]=-1/90*KE/dx**2
    A[i,i]=49/18*KE/dx**2+V(xGrid[i]) 

# Solve for eigenvalues
E, wfn = LA.eigh(A)
lz = []
print('-----------------------------------')
print('Harmonic Energy State Data')
print('-----------------------------------')
for i in range(5):
    v = E[i+1]-E[i]
    w = v/heV/c
    print('Energy state {0} - Energy State {1}'.format(i+2,i+1))
    print('Energy difference: \t{} eV'.format(v))
    print('Vibrational frequency: \t{} cm-1'.format(w))
    print('-----------------------------------')
    lz.append(E[i])
for i in range(5):
    plt.plot(xGrid,wfn[:,i]+lz[i],color='b',label=None)
    
# Read harmonic potential energy file
X = np.loadtxt(r'harmonic62.csv',delimiter=',',usecols=(0,))
E = np.loadtxt(r'harmonic62.csv',delimiter=',',usecols=(1,))
E -=min(E)

eVolt = 1.60218e-19 # conversion factor from eV to J
heV = 4.135667662e-15 # Planck's constant in ev.s
A2M2 = 1e-20 # conversion factor from sq. Angstrom to sq m
mAds = 1.574528e-27 # mass of proton
c = 29979245800 # speed of light

# Calculate the kinetic energy cefficient
KE = heV*heV*eVolt/(8*np.pi**2*mAds*A2M2)

# Min and max for grid
xMin = min(X)
xMax = max(X)

# Fit a curve to X,E data
xnew = np.linspace(xMin,xMax,100)
V = interp1d(X,E, kind='cubic',bounds_error=False,fill_value='extrapolate')
# fig = plt.figure()
# ax = fig.add_subplot(1,1,1)
# ax.plot(xnew,V(xnew))
# plt.show()
plt.plot(xnew,V(xnew),color='r',label='Harmonic')

# Solving the Schrodinger equation using finite difference
L = xMax +.5
n = 1000;
dx = 2*L/n
xGrid = np.arange(-L+dx,L,dx)
A = np.zeros((n-1,n-1))
for i in range(n-1):
    for j in range(n-1):
        if i==j+1 or i==j-1:
            A[i,j]=-3/2*KE/dx**2
        if i==j+2 or i==j-2:
            A[i,j]=3/20*KE/dx**2
        if i==j+3 or i==j-3:
            A[i,j]=-1/90*KE/dx**2
    A[i,i]=49/18*KE/dx**2+V(xGrid[i]) 

# Solve for eigenvalues
E, wfn = LA.eigh(A)
lz = []
print('-----------------------------------')
print('Harmonic Energy State Data')
print('-----------------------------------')
for i in range(5):
    v = E[i+1]-E[i]
    w = v/heV/c
    print('Energy state {0} - Energy State {1}'.format(i+2,i+1))
    print('Energy difference: \t{} eV'.format(v))
    print('Vibrational frequency: \t{} cm-1'.format(w))
    print('-----------------------------------')
    lz.append(E[i])
for i in range(5):
    plt.plot(xGrid,wfn[:,i]+lz[i],color='r',label=None)
plt.ylim([0,2.2])
plt.ylabel('Energy (eV)')
plt.xlabel('Distance (Å)')
plt.legend(loc='center left', bbox_to_anchor=(1, 0.5),fancybox = True, shadow = True)
plt.show()
#+END_SRC

#+END_COMMENT

** Lecture 8: Rigid Rotor
*** Classical rigid rotor
1. Compare rotation about an axis vs linear motion
2. Moment of intertia $I=\mu r^2$
3. Angular momentum, $\mathbf{l} = I \mathbf{\omega} = \mathbf{r}\times \mathbf{p}$, $T= l^2/2I$ 
   1. Angular momentum and energy continuous variables
*** Quantum rotor in a plane
1. Angular momentum and kinetic energy operators in polar coordinates,
      $\hat l_z = -i\hbar \frac{d}{d\phi}$
2. Eigenfunctions degenerate, cw and ccw rotation
3. No zero point energy
4. Angular momentum eignefunctions, $l_z = m_l \hbar$
5. Energy superpositions and localization 

#+BEGIN_SRC python :exports results :results output
import matplotlib.pyplot as plt
import numpy as np

def s(theta):
    return np.full(np.size(theta),  1./np.sqrt(2*np.pi))

def py(theta):
    return s(theta)*2.*np.sin(theta)

def dy(theta):
    return s(theta)*2.*np.sin(2.*theta)

rad = np.arange(0, 2*np.pi, 0.01)
radpi = np.arange(0, np.pi, 0.01)
rad2pi = np.arange(np.pi, 2*np.pi, 0.01)

rad1 = np.arange(0, np.pi/2., 0.02)
rad2 = np.arange(np.pi/2., np.pi, 0.02)
rad3 = np.arange(np.pi, 1.5*np.pi, 0.02)
rad4 = np.arange(1.5*np.pi, 2.*np.pi, 0.02)
plt.figure()
plt.subplot(1,3,1,projection='polar',)
plt.plot(rad1,s(rad1),color='blue')
plt.plot(rad2,s(rad2),color='blue')
plt.plot(rad3,s(rad3),color='blue')
plt.plot(rad4,s(rad4),color='blue')

plt.subplot(1,3,2,projection='polar')
plt.plot(rad1,py(rad1),color='blue')
plt.plot(rad2,py(rad2),color='blue')
plt.plot(rad3,-py(rad3),color='red')
plt.plot(rad4,-py(rad4),color='red')

#plt.plot(rad2pi,np.abs(py(radpi)), color='red')
plt.subplot(1,3,3,projection='polar')
plt.plot(rad1,dy(rad1),color='blue')
plt.plot(rad2,-dy(rad2),color='red')
plt.plot(rad3,dy(rad3),color='blue')
plt.plot(rad4,-dy(rad4),color='red')
plt.savefig('./Images/2Drotor.png')
#+END_SRC

#+RESULTS:

#+BEGIN_EXPORT latex
\begin{table}[H]
   \begin{center}
   \caption{2-D rigid rotor model}
    \label{Rigid rotor}
\begin{tabular}[H]{|c|}
\hline
 \\
$\displaystyle       V(\phi) = 0, 0 \leq \phi \leq 2\pi $ \\
 \\
$\displaystyle \hat H = -\frac{\hbar^2}{2 I} \frac{\partial^2}{\partial
  \phi^2},\ \ \ \ \ I=\mu R^2
$\\
\\
$\displaystyle     \psi_{m_l}(\phi) = \frac{1}{\sqrt{2\pi}} e^{-i m_l \phi}, m_l
= 0, \pm 1, \pm 2, \ldots $ \\
\\
$\displaystyle     E_{m_l}=\frac{\hbar^2}{2 I}m_l^2$ 
 \\
$\displaystyle L_z = m_l \hbar$ \\
\\ \underline{Absorption Selection Rules}: 
$\displaystyle \Delta m_l = \pm 1$
\\
     \includegraphics[scale=0.8]{Images/2Drotor.png} \\       
\hline
\end{tabular}
 \end{center}
\end{table}
#+END_EXPORT

*** Quantum rotor in 3-D
1. Angular momentum and kinetic energy operators in spherical coordinates
2. Spherical harmonic solutions, $Y_{lm_l}$
3. Azimuthal QN $l=0, 1, \ldots$
4. Magnetic QN $m_l = -l, -l+1, ..., l$
5. Energy spectrum, $2 l + 1$ degeneracy
6. Vector model - can only know total total $|L|$ and $L_z$
7. Wavefunctions look like atomic orbitals, $l$ nodes

#+BEGIN_EXPORT latex
\begin{table}[H]
   \begin{center}
   \caption{3-D rigid rotor model}
    \label{3-D Rigid rotor}
\begin{tabular}[H]{|c|}
\hline
 \\
$\displaystyle       V(\theta,\phi) = 0, 0 \leq \phi \leq 2\pi, 0 \leq \theta <
\pi$ \\
 \\
$\displaystyle     \hat L^2 = -\hbar^2 \left [
  \frac{1}{\sin^2\theta}\frac{\partial^2}{\partial \phi^2}+\frac{1}{\sin
    \theta}\frac{\partial}{\partial \theta}\left ( \sin \theta
    \frac{\partial}{\partial \theta}\right ) \right ] $ \\
\\
$\displaystyle \hat H_\text{rot} = \frac{1}{2 I} \hat L^2$ \\
\\
$\displaystyle     Y_{lm_l}(\theta,\phi)=N_l^{|m|}P_l^{|m|}(\cos(\theta))e^{im_l\phi}$ \\
\\
$\displaystyle l = 0, 1, 2, \ldots, \ \ \ \ \ \ m_l = 0,\pm 1, \ldots, \pm l$
\\
\\
$\displaystyle     E_{l}=\frac{\hbar^2}{2 I}l(l+1)$ \\
 \\
$\displaystyle |L| = \hbar \sqrt{l(l+1)}, L_z = m_l \hbar $ \\
\\ \underline{Selection Rules} \\
$\displaystyle \Delta l = \pm 1\qquad \Delta m_l = 0, \pm 1 $
\\
\end{tabular}
\begin{tabular}[H]{|ccc|}
\includegraphics[scale=0.4]{./Images/s.png} &
\includegraphics[scale=0.4]{./Images/p.png} &
\includegraphics[scale=0.4]{./Images/d.png} \\
$s\ (l=0) $ & $d\ (l=1)$ & $p\ (l=2)$ \\
\hline
\end{tabular}
 \end{center}
\end{table}
#+END_EXPORT


#+BEGIN_SRC python :exports results :results output
import matplotlib.pyplot as plt
from matplotlib import cm, colors
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
from scipy.special import sph_harm

phi = np.linspace(0, np.pi, 100)
theta = np.linspace(0, 2*np.pi, 100)
phi, theta = np.meshgrid(phi, theta)

# The Cartesian coordinates of the unit sphere
x = np.sin(phi) * np.cos(theta)
y = np.sin(phi) * np.sin(theta)
z = np.cos(phi)

m, l = 0, 0

# Calculate the spherical harmonic Y(l,m) and normalize to [0,1]
fcolors = sph_harm(m, l, theta, phi).real
fmax, fmin = fcolors.max(), fcolors.min()
fcolors = (fcolors - fmin)/(fmax - fmin)

# Set the aspect ratio to 1 so our sphere looks spherical
sfig = plt.figure(figsize=plt.figaspect(1.))
s = sfig.add_subplot(111, projection='3d')
s.plot_surface(x, y, z,  rstride=1, cstride=1, facecolors=cm.seismic(fcolors))
# Turn off the axis planes
s.set_axis_off()
plt.savefig('./Images/s.png')

m, l = 0, 1

# Calculate the spherical harmonic Y(l,m) and normalize to [0,1]
fcolors = sph_harm(m, l, theta, phi).real
fmax, fmin = fcolors.max(), fcolors.min()
fcolors = (fcolors - fmin)/(fmax - fmin)

# Set the aspect ratio to 1 so our sphere looks spherical
# fig = plt.figure(figsize=plt.figaspect(1.))
pfig = plt.figure(figsize=plt.figaspect(1.))
p = pfig.add_subplot(111, projection='3d')
p.plot_surface(x, y, z,  rstride=1, cstride=1, facecolors=cm.seismic(fcolors))
# Turn off the axis planes
p.set_axis_off()

plt.savefig('./Images/p.png')

m, l = 1, 2

# Calculate the spherical harmonic Y(l,m) and normalize to [0,1]
fcolors = sph_harm(m, l, theta, phi).real
fmax, fmin = fcolors.max(), fcolors.min()
fcolors = (fcolors - fmin)/(fmax - fmin)

# Set the aspect ratio to 1 so our sphere looks spherical
# fig = plt.figure(figsize=plt.figaspect(1.))
dfig = plt.figure(figsize=plt.figaspect(1.))
d = dfig.add_subplot(111, projection='3d')
d.plot_surface(x, y, z,  rstride=1, cstride=1, facecolors=cm.seismic(fcolors))
# Turn off the axis planes
d.set_axis_off()

plt.savefig('./Images/d.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_COMMENT
#+BEGIN_EXPORT LaTeX
\begin{figure}
\includegraphics[scale=0.4]{./Images/s.png}
\includegraphics[scale=0.4]{./Images/p.png}
\includegraphics[scale=0.4]{./Images/d.png}
\caption{Pythonic $s$ ($l = 0$), $p$ ($l=1$), and $d$ ($l=2$) spherical harmonics. Color scale from red to white to blue corresponds to positive to zero to negative sign of wavefunction.}
\end{figure}
#+END_EXPORT
replace. Tab to end.
#+END_COMMENT

*** Particle angular momentum
1. Fermions, mass, half-integer spin
   1. Electron, $s=1/2, m_s=\pm 1/2$
2. Bosons, force-carrying, integer spin
*** Diatomic rotational spectroscopy
1. Apply rigid rotor model
2. Rotational constant $\tilde{B} = (\hbar^2/2I)/hc = \hbar/4\pi I c$ cm$^{-1}$, $I=\mu R_\mathrm{eq}^2$
3. Gross selection rule: dynamic dipole moment non-zero (heteronuclear, not homonuclear)
4. Specific selection rule: $\Delta l=\pm 1$, $\Delta m_l=0, \pm1$
5. $\Delta \tilde{E_l}  = 2\tilde{B}(l+1)$ cm$^{-1}$
6. Rotational state populations
** Lecture 9: Spectroscopy :noexport:
*** Spectroscopy is quantitative measurement of interaction of light with matter
1. Observed $I(\nu)/I(\nu_0)$
2. Bohr condition, $|E_f-E_i|/h=\nu =c\tilde{\nu}=c/\lambda$
3. Intensities determined by populations of initial and final states (from Boltzmann distribtuion) and transition probabilities (gross and specific selection rules)
*** Einstein coefficients
1. Stimulated absorption, $dn_1/dt= -n_1 B\rho(\nu)$
2. Stimulated emission, $dn_2/dt= -n_2 B\rho(\nu)$
3. Spontaneous emission, $dn_2/dt=-n_2 A, A=\left ( \frac{8\pi h
              \nu^3}{c^3}\right )B$
4. $1/A=$ lifetime
*** Transition probability
1. Einstein coefficient $B_{if}=\frac{|\mu_{if}|^2}{6\epsilon_0\hbar^2}$
2. Classical electric dipole, $\overrightarrow{\mu}=q \cdot
          \overrightarrow{l}$, quantum dipole operator $\hat\mu = e\cdot \overrightarrow{r}$
3. Transition dipole moment, $\mu_{if} = \left(
        \frac{d\mu}{dx}\right ) \langle \psi_i|\hat\mu |\psi_f \rangle$
4. Selection rules---conditions that make $\mu_{if}$ non-zero,
      "allowed" vs "forbidden" transitions
** Lecture 10: Vibrational and rotational spectroscopy :noexport:
*** Diatomic rotational spectroscopy
1. Apply rigid rotor model
2. Rotational constant $\tilde{B} = (\hbar^2/2I)/hc = \hbar/4\pi I c$ cm$^{-1}$, $I=\mu R_\mathrm{eq}^2$
3. Gross selection rule: dynamic dipole moment non-zero (heteronuclear, not homonuclear)
4. Specific selection rule: $\Delta l=\pm 1$, $\Delta m_l=0, \pm1$
5. $\Delta \tilde{E_l}  = 2\tilde{B}(l+1)$ cm$^{-1}$
6. Rotational state populations
*** Polyatomic rotational spectroscopy
1. Three distinct moments of intertia ($I_x, I_y, I_z$)
2. Spectra more complex
*** Diatomic vibrational spectroscopy
1. Apply harmonic oscillator model
2. Vibrational constant $\tilde{\nu} = (\sqrt{k/\mu}/2\pi)/hc$ cm$^{-1}$
3. Gross selection rule: dynamic dipole $d\mu/dx$ non-zero (heteronuclear, non homonuclear)
4. Specific selection rule: dipole integral $\langle \psi_v|\hat\mu|\psi_{v^\prime} \rangle =0$
          unless $\Delta v = \pm 1$
5. Allowed $\Delta \tilde{E}_v = \tilde{\nu}$ cm$^{-1}$
6. Boltzmann distribution implies $v=0$ states dominate at normal $T$
*** Raman spectroscopy
1. Shine in light of arbitrary frequency $\tilde{\nu_0}$, mostly get out the same
2. Some light comes out at $\tilde{\nu_0}-\tilde{\nu}$ (Stoke's line)
3. Some light comes out at $\tilde{\nu_0}+\tilde{\nu}$ (anti-Stoke's line)
4. Gross selection rule: dynamic polarizability non-zero (homonuclear, not heteronuclear)
*** Anharmonicity, Morse potential
*** Vibration-rotation spectroscopy
1. Harmonic oscillator + rigid rotor
2. Selection rules: $\Delta v = \pm 1, \Delta l=\pm 1$
3. $R$ branch: $\Delta \tilde E  = \tilde \nu + 2B(l+1), \Delta l = 1$ 
4. $P$ branch: $\Delta \tilde E = \tilde \nu - 2B(l), \Delta l = -1$
#+CAPTION: Rovibrational spectrum of carbon monoxide
#+ATTR_LATEX: :width 0.5\textwidth
[[./Images/CO-rovib.png]]
*** Polyatomic vibrational spectroscopy
1. Polyatomics, $3n-6$ ($3n-5$ for linear polyatomic) vibrational modes
2. Selection rules and degeneracies affect number of observed features
3. CO$_2$ example
** Lecture 11: Hydrogen atom
*** Schr\ouml{}dinger equation
1. Spherical coordinates and separation of variables
2. Coulomb potential $v_\mathrm{Coulomb}(r)=-\frac{e^2}{4\pi\epsilon_0}\frac{1}{r}$
3. Centripetal potential  $v=\hbar^2\frac{l(l+1)}{2\mu r^2}$
*** Solutions
1. $\psi(r,\theta,\phi)=R_{nl}(r)Y_{lm}(\theta,\phi)$
2. Principle quantum number $n=1,2,\ldots$
   1. $K$, $L$, $M$, $N$, ... shells
   2. $n-1$ radial nodes
3. Azimuthal quantum number $l=0,1,...,n-1$
   1. $s$, $p$, $d$, ... orbital sub-shells
   2. $l$ angular nodes
4. Magnetic quantum number $m_l=-l,-l+1,...,l$
5. Spin quantum number $m_s=\pm 1/2$
6. Energy spectrum and populations
7. Electronic selection rules
   1. $\Delta l=\pm 1 \quad \Delta m_s =0 \quad \Delta m_l = 0,\pm 1$
9. Wavefunctions = "orbitals",  [[https://colab.research.google.com/github/wmfschneider/CHE30324/blob/master/Resources/Hydrogen_3d.ipynb][3d H atom notebook]]
10. Integrate out angular components to get radial probability function $P_{nl}(r)=r^2 R_{nl}^2(r)$
    1. $\langle r\rangle = \int r P_{nl}(r) dr = \left(\frac{3}{2}n^2-l(l+1)\right)a_0$

#+BEGIN_SRC python :exports results :results output
import matplotlib.pyplot as plt
import numpy as np
from sympy.physics.hydrogen import E_nl
from sympy.physics.hydrogen import R_nl
from sympy import symbols
from sympy.plotting import plot
from sympy import var

#fig = plt.gcf()

var('r')
max = 10

r = np.linspace(0,max,100)
Ones = np.array([R_nl(1, 0, x) for x in r],dtype='float')
plt.plot(r,Ones,label='1s')
Twos = np.array([R_nl(2, 0, x) for x in r],dtype='float')
plt.plot(r,Twos,label='2s')
Twop = np.array([R_nl(2, 1, x) for x in r],dtype='float')
plt.plot(r,Twop,label='2p')

plt.plot([0,max],[0,0],color='black',linestyle=':')
plt.xlim(0,max)
plt.xlabel('Distance (a0)')
plt.ylabel('Wavefunction R(r)')

plt.legend()
plt.title('H atom radial wavefunctions')
plt.savefig('./Images/H-R.png')

plt.figure()
Ones = np.array([x*x*R_nl(1, 0, x)**2 for x in r],dtype='float')
plt.plot(r,Ones,label='1s')
Twos = np.array([x*x*R_nl(2, 0, x)**2 for x in r],dtype='float')
plt.plot(r,Twos,label='2s')
Twop = np.array([x*x*R_nl(2, 1, x)**2 for x in r],dtype='float')
plt.plot(r,Twop,label='2p')

plt.plot([0,max],[0,0],color='black',linestyle=':')
plt.xlim(0,max)
plt.xlabel('Distance (a0)')
plt.ylabel('Radial probability P(r)')
plt.title('H atom radial probability functions')

plt.legend()
plt.savefig('./Images/H-P.png')

#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+CAPTION: H atom wavefunctions
#+ATTR_LATEX: :width 0.5\textwidth
[[./Images/H-R.png]] 
#+CAPTION: H atom radial probability
#+ATTR_LATEX: :width 0.5\textwidth
[[./Images/H-P.png]] 

#+BEGIN_SRC python :exports results :results output
# 3D images of Hydrogen orbitals
import plotly.graph_objects as go
import numpy as np
from sympy.physics.hydrogen import R_nl
from sympy import Ynm
from sympy import var

var('r theta phi')

n = 1
l = 0
m = 0
Z = 1

xmesh=[]
ymesh=[]
zmesh=[]
psi=[]

points=20
gsize=10

for z in np.linspace(-gsize,gsize,points):
    for y in np.linspace(-gsize,gsize,points):
        for x in np.linspace(-gsize,gsize,points):
            xmesh.append(x)
            ymesh.append(y)
            zmesh.append(z)

            r = np.sqrt(x**2+y**2+z**2)
            theta=np.arccos(z/r)
            phi=np.arctan(y/x)

            value=R_nl(n,l,r,Z)* Ynm(l,m,theta,phi).evalf() 
            psi.append(float(value))

#            print('{0:6.3f} {1:6.3f} {2:6.3f} {3:6.3f} {4:6.3f} {5:6.3f} {6:6.3f}'.format(x,y,z,r,theta,phi,psi))

iso = 0.3*max(psi)

fig= go.Figure(data=go.Isosurface(
        x=xmesh,
        y=ymesh,
        z=zmesh,
        value=psi,
        isomin=-iso,
        isomax=iso,
        surface_count=2,
        opacity=1.0,
        showscale=False,
        caps=dict(x_show=False, y_show=False,z_show=False)
    ))

fig.show()
#fig.write_image('./Images/1s-3D.png')
# i=0
# for plan in plans:
#     fig= go.Figure(data=go.Isosurface(
#         x=xmesh,
#         y=ymesh,
#         z=zmesh,
#         value=array[i],
#         isomin=-iso,
#         isomax=iso,
#         surface_count=2,
#         opacity=0.5,
#         showscale=False,
#         caps=dict(x_show=False, y_show=False,z_show=False)
#     ))

#     fig.write_image('./Images/'+plan[3]+'.png')
#     i+=1
#+END_SRC

#+RESULTS:

*** /Variational principle/
1. Solutions of Schr\ouml{}dinger equation always form a complete set
2. True wavefunction energy is therefore lower bound on energy of any trial wavefunction
    \[\langle \psi_\text{trial}^\lambda | \hat{H} | \psi_\text{trial}^\lambda\rangle =E_\text{trial}^\lambda \geq E_0\]
3. Optimize wavefunction with respect to variational parameter
    \[ \left ( \frac{\partial \langle \psi_\text{trial}^\lambda | \hat{H} | \psi_\text{trial}^\lambda\rangle}{\partial\lambda} \right ) = 0 \rightarrow \lambda_\text{opt} \] 


#+BEGIN_EXPORT latex
\begin{table}[H]
   \begin{center}
   \caption{Hydrogen atom}
    \label{Hydrogen atom}
\begin{displaymath}
\begin{array}{|c|}
\hline
      V(r) = -\frac{e^2}{4\pi\epsilon_0}\frac{1}{r}, 0 < r< \infty \\[0.3cm]

      \hat H = -\frac{\hbar^2}{2m_e}\frac{1}{r^2}\left [
  \frac{\partial}{\partial r}r^2\frac{\partial}{\partial r} + \hat L^2 \right ] +V(r) \\[0.3cm]

   \psi(r,\theta,\phi) = R(r)Y_{l,m_l}(\theta,\phi)  \\[0.3cm]
 \left \{ -\frac{\hbar^2}{2m_e}\frac{1}{r^2}
            \frac{d}{d r} \left ( r^2 \frac{d}{dr}\right ) + \frac{\hbar^2
              l(l+1)}{2 m_e r^2}
          -\frac{e^2}{4\pi\epsilon_0}\frac{1}{r}\right \} R(r) = E R(r)  \\[0.3cm]

 R_{nl}(r) = N_{nl} e^{-x/2} x^l L_{nl}(x),\ \ \  x = \frac{2 r}{n a_0} \\[0.3cm]

 P_{nl}(r) = r^2 R_{nl}^2 \\[0.3cm]
 n = 1, 2, \ldots,\ \  l = 0, \ldots, n-1 \ \ m_l = 0,\pm 1, \ldots, \pm l \\[0.3cm]
 N_{nl} = \sqrt{\left ( \frac{2}{na_0}\right )^3 \frac{(n-l-1)!}{2n(n+l)!}} \\[0.3cm]
 L_{10} = L_{21} = L_{32} = \ldots =1 \quad L_{20} = 2 - x \quad L_{31} = 4-x \\[0.3cm]
  E_{n}=-\frac{1}{2}\frac{\hbar^2}{m_e a_0^2}\frac{1}{n^2} =-\frac{E_H}{2}\frac{1}{n^2} \\[0.3cm]
 |L| = \hbar \sqrt{l(l+1)}, L_z = m_l \hbar  \\[0.3cm]
 \langle r \rangle = \left \{ \frac{3}{2} n^2 - \frac{1}{2} l(l+1) \right \} \frac{a_0}{Z} \\[0.3cm]

 \text{Selection Rules}:
 \Delta l = \pm 1, \qquad  \Delta m_l = 0, \pm 1\qquad \Delta m_s=0  \\
%%     \includegraphics[scale=0.4]{Images/H_atom} \\       
\hline
\end{array}
\end{displaymath}
 \end{center}
\end{table}
#+END_EXPORT

#+BEGIN_COMMENT
#+BEGIN_EXPORT latex
\begin{table}[H]
   \begin{center}
   \caption{Hydrogen atom}
    \label{Hydrogen atom}
\begin{tabular}{|c|}
\hline
 \\
$\displaystyle       V(r) = -\frac{e^2}{4\pi\epsilon_0}\frac{1}{r}, 0 < r< \infty$ \\
 \\
$\displaystyle     \hat H = -\frac{\hbar^2}{2m_e}\frac{1}{r^2}\left [
  \frac{\partial}{\partial r}r^2\frac{\partial}{\partial r} + \hat L^2 \right ] +V(r)$ \\
\\
$\displaystyle \psi(r,\theta,\phi) = R(r)Y_{l,m_l}(\theta,\phi) $ \\
\\
$\displaystyle   \left \{ -\frac{\hbar^2}{2m_e}\frac{1}{r^2}
            \frac{d}{d r} \left ( r^2 \frac{d}{dr}\right ) + \frac{\hbar^2
              l(l+1)}{2 m_e r^2}
          -\frac{e^2}{4\pi\epsilon_0}\frac{1}{r}\right \} R(r) = E R(r) $ \\
\\
$\displaystyle R_{nl}(r) = N_{nl} e^{-x/2} x^l L_{nl}(x),\ \ \  x = \frac{2 r}{n a_0} $
\\
$\displaystyle P_{nl}(r) = r^2 R_{nl}^2 $
\\
\\
$\displaystyle n = 1, 2, \ldots,\ \  l = 0, \ldots, n-1 \ \ m_l = 0,\pm 1, \ldots, \pm l$
\\
\\
$\displaystyle N_{nl} = \sqrt{\left ( \frac{2}{na_0}\right )^3 \frac{(n-l-1)!}{2n(n+l)!}}$
\\
\\
$\displaystyle L_{10} = L_{21} = L_{32} = \ldots =1 \quad L_{20} = 2 - x \quad L_{31} = 4-x$
\\
\\
$\displaystyle     E_{n}=-\frac{1}{2}\frac{\hbar^2}{m_e a_0^2}\frac{1}{n^2} =-\frac{E_H}{2}\frac{1}{n^2}$ \\
 \\
$\displaystyle |L| = \hbar \sqrt{l(l+1)}, L_z = m_l \hbar $ \\
\\
$\displaystyle \langle r \rangle = \left \{ \frac{3}{2} n^2 - \frac{1}{2} l(l+1) \right \} \frac{a_0}{Z} $ \\

\\ \underline{Selection Rules}:
$\displaystyle \Delta l = \pm 1, \qquad  \Delta m_l = 0, \pm 1\qquad \Delta m_s=0 $
\\
%%     \includegraphics[scale=0.4]{Images/H_atom} \\       
\hline
\end{tabular}
 \end{center}
\end{table}
#+END_EXPORT
#+END_COMMENT

** Lecture 12: Many-electron atoms
*** Many-electron problem, Schr\ouml{}dinger equation not exactly solvable (Sad!)
1. $e^- -e^-$ interaction terms prevent separation of variables
2. /Independent electron/ model basis of all solutions, describes each electron (pair) by its own wavefunction, or "orbital," $\psi_i$
\[ \left \{ -\frac{\hbar^2}{2m_e}\nabla^2 - \frac{Z}{r} + v_\text{ee} \right \}\psi_i = \epsilon_i \psi_i \]
*** Qualitative solutions
 1. $\psi_i$ look like H atom orbitals,  labeled by same quantum numbers
 2. /Aufbau principle/: ``Build-up'' electron configuration by adding electrons into H-atom-like orbitals, from bottom up
 3. /Pauli exclusion principle/: Every electron in atom must have a unique set of quantum numbers, so only two per orbital (with opposite spin)
 4. /Pauli exclusion principle (formally)/: The wavefunction of a multi-particle system must be anti-symmetric to coordinate exchange if the particles are fermions, and symmetric to coordinate exchange if the particles are bosons
 5. /Hund's rule/: Electrons in degenerate orbitals prefer to be spin-aligned.  Configuration with highest /spin multiplicity/ is the most preferred
| $S$   | $2S+1$ | multiplicity |
|-------+--------+--------------|
| 0     |      1 | singlet      |
| $1/2$ |      2 | doublet      |
| 1     |      3 | triplet      |
| $3/2$ |      4 | quartet      |
*** Structure of the periodic table
1. Electrons in different subshells experience different effective nuclear charge $Z_\mathrm{eff} = Z - \sigma_{nl}$
2. Inner ("core") shells not shielded well, decrease precipitously in energy with increasing \(Z\)
3. Inner shell electrons "shield" outer electrons well
4. Within a family (column), outmost $n$ increases, further from nucleus, energy goes up
5. Within a period (row), $s$ shielded less than $p$ less than $d$ ..., causes degeneracy to break down
6. Electrons in same subshell shield each other poorly, causing ionization energy to increase across the subshell

#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 0.7\textwidth
[[./Images/PeriodicTableMuted.png]]
*** Quantitative solutions
1. Schr\ouml{}dinger equation
     \[\hat H \Psi({\bf r}_1, {\bf r}_2,...)=E \Psi({\bf r}_1, {\bf r}_2,...)\]
     \[\hat H = \sum_i \hat h_i + \frac{e^2}{4 \pi
          \epsilon_0}\sum_i\sum_{j>i}\frac{1}{|{\bf r}_i-{\bf r}_j|}\]
     \[\hat h_i = -\frac{\hbar^2}{2m_e}\nabla^2_i-\frac{Z
          e^2}{4\pi\epsilon_0}\frac{1}{|{\bf r}_i|}\]
2. Construct candidate many-electron wavefunction $\Psi$ from one
      electron wavefunctions (mathematical details vary with exact approach)
     \[\Psi({\bf r}_1, {\bf r}_2,...)\approx \psi_1({\bf
            r}_1)\psi_2({\bf r}_2)...\psi_n({\bf r}_n)\]
3. Calculate expectation value of $E$ of approximate model and apply
       /variational principle/ to find equations that describe "best" (lowest
	total energy) set of $\psi_i$
	\[\frac{\partial E}{\partial \psi_i}=0 \ \ \ \forall i\]
	\[\hat f\psi=\left\{\hat h + \hat v_\mathrm{Coul}[\psi_i] + \hat
            v_\mathrm{ex}[\psi_i]+\hat v_\mathrm{corr}[\psi_i] \right\}\psi=\epsilon\psi\]
	\[E=\sum_i \epsilon_i-\frac{1}{2}\langle \Psi |\hat v_\mathrm{Coul}[\psi_i] + \hat
            v_\mathrm{ex}[\psi_i]+\hat v_\mathrm{corr}[\psi_i]|\Psi \rangle\]
4. Motivate as equation for an electron moving in a "field" of
          other electrons, adding an electron to a known set of $\psi_i$
*** Electron-electron interactions
   1. Coulomb ($\hat v_\mathrm{Coul}$): classical repulsion between distinguishable electron "clouds"
   2. Exchange ($\hat v_\mathrm{ex}$): accounts for electron indistinguishability (Pauli principle for fermions).  Decreases Coulomb repulsion because electrons of like spin intrinsically avoid one another
   3. Correlation ($\hat v_\mathrm{corr}$): decrease in Coulomb repulsion due to dynamic ability of electrons to avoid one another; "fixes" orbital approximation
   4. General form of exchange potential is expensive to calculate; general form of correlation potential is unknown
*** Popular models
1. /Hartree model/: Include only classical Coulomb repulsion $\hat v_\mathrm{Coul}$
2. /Hartree-Fock model/: Include Coulomb and exchange
3. /Density-functional theory/ (DFT): Include Coulomb and
	approximate expressions for exchange and correlation         
*** Numerical solution 
1. All potential terms $\hat v$ depend on the solutions, so  equations must be solved /iteratively/ to /self-consistency/
2. Solved numerically on a grid or by expanding solutions in a basis set
*** DFT calculations on atoms
1. See [[../Resources/fda/00README.txt][README]] at [[../Resources/fda]]

#+BEGIN_SRC python :exports results :results output
import matplotlib.pyplot as plt
import numpy as np
from sympy.physics.hydrogen import E_nl
from sympy.physics.hydrogen import R_nl
from sympy import symbols
from sympy.plotting import plot
from sympy import var

#fig = plt.gcf()
aueV = 27.2114

Atom = ["He", "Ne", "Ar", "Kr"]
IPexpt = np.array([24.59, 21.56, 15.76,14.00])
IPXalpha = np.array([0.8998,0.7912,0.5735,0.5130]) # Hartree
IPXalphaeV = IPXalpha*aueV

offset = -0.7
plt.figure()
for i in [0,1,2,3]:
    plt.scatter(IPexpt[i],IPXalphaeV[i],color='black')
    plt.text(IPexpt[i],IPXalphaeV[i]+offset,Atom[i],color='black')
plt.plot([13,25],[13,25],color='black',linestyle=':',label='y=x')
plt.xlabel('Experiment (eV)')
plt.ylabel('DFT (eV)')
plt.legend()

plt.title('DFT-computed vs experimental 1st ionization energies')

plt.savefig('./Images/Ionization.png')

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :exports results :results output
import matplotlib.pyplot as plt
import numpy as np
import os

name='H'
radius=15

# Hydrogen
L1 = ["300  0.0001  30.0\n"]
L2 = ["50 0.00001 0.10 0.50  0.682 0.0042\n"]
L3 = ["1.0 1\n"] # Z and number of states to compute
L4 = ["1 0 1.0 0.0\n"]  # n l up down
L = L1 + L2 + L3 + L4

with open('../Resources/fda/Atoms/'+name+'.inp', 'w') as f:
     f.writelines(L)

os.system('../Resources/fda/fda ../Resources/fda/Atoms/'+name)

# Lets open the file in read mode
with open('../Resources/fda/Atoms/'+name+'.dmp', 'r') as f:

    # Reading all the lines in the file
    # Each line is stored as an element of a list
    lines = f.readlines()

    # First we read the grid points and the total charge densities
grid_points = []
total_charge_densities = []

for line in lines[3:303]:

     # Each is a string with two columns
     grid_point, tot_charge_density = line.split()

     # We need to convert each line to a float add it to our lists
     grid_points.append(float(grid_point))
     total_charge_densities.append(float(tot_charge_density))
    
# Now for the 1s orbital
one_s = []
one_s = [float(x) for x in lines[304:604]]
 

plt.figure()
#plt.semilogx(grid_points, total_charge_densities)
plt.plot(grid_points, total_charge_densities)
plt.xlabel('Grid Points')
plt.ylabel('Charge Density (electrons/bohr')
plt.title(name+' Radial Charge Density')
plt.xlim(0,radius)
plt.savefig('./Images/'+name+'-overall-charge-density.png')

plt.figure()
plt.plot(grid_points, one_s,label='1s')
plt.legend()
plt.xlim(0,radius)

plt.xlabel('Distance (bohr)')
plt.ylabel('Wavefunction rR(r)')
plt.title(name+' radial wavefunctions')
plt.savefig('./Images/'+name+'-wave-functions.png')
#plt.show()

with open('../Resources/fda/Atoms/'+name+'.out', 'r') as f:
    lines = f.readlines()

echo = 0
for line in lines:
     if echo == 1:
          print(line.strip())
     elif line.strip() == "Orbital Summary":
          print(name+' '+line.strip())
          echo = 1

#+End_SRC

#+RESULTS:
#+begin_example
H Orbital Summary
nl    occ        E           KE       <1/r>     <r>
1s   1.00      -0.5002      0.5003    1.0005   1.4994

Energy Summary
kinetic energy      =     0.5003
potential energy    =    -1.0005
one-electron energy =    -0.5001
two-electron energy =    -0.0000

total energy =    -0.5002
virial ratio =    -1.9996
#+end_example


#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 0.5\textwidth
[[./Images/H-wave-functions.png]]


#+BEGIN_SRC python :exports results :results output
import matplotlib.pyplot as plt
import numpy as np
import os

# Helium
L1 = ["300  0.0001  30.0\n"]
L2 = ["50 0.00001 0.10 0.50  0.682 0.0042\n"]
L3 = ["2.0 1\n"] # Z and number of states to compute
L4 = ["1 0 1.0 1.0\n"]  # n l up down
L = L1 + L2 + L3 + L4

name='He'
radius=15

with open('../Resources/fda/Atoms/'+name+'.inp', 'w') as f:
     f.writelines(L)

os.system('../Resources/fda/fda ../Resources/fda/Atoms/'+name)

# Lets open the file in read mode
with open('../Resources/fda/Atoms/'+name+'.dmp', 'r') as f:

    # Reading all the lines in the file
    # Each line is stored as an element of a list
    lines = f.readlines()

    # First we read the grid points and the total charge densities
grid_points = []
total_charge_densities = []

for line in lines[3:302]:

     # Each is a string with two columns
     grid_point, tot_charge_density = line.split()

     # We need to convert each line to a float add it to our lists
     grid_points.append(float(grid_point))
     total_charge_densities.append(float(tot_charge_density))
    
# Now for the 1s orbital
one_s = []
one_s = [float(x) for x in lines[304:603]]
 

plt.figure()
#plt.semilogx(grid_points, total_charge_densities)
plt.plot(grid_points, total_charge_densities)
plt.xlabel('Grid Points')
plt.ylabel('Charge Density (electrons/bohr')
plt.title(name+' Radial Charge Density')
plt.xlim(0,radius)
plt.savefig('./Images/'+name+'-overall-charge-density.png')

plt.figure()
plt.plot(grid_points, one_s,label='1s')
plt.legend()
plt.xlim(0,radius)

plt.xlabel('Distance (bohr)')
plt.ylabel('Wavefunction rR(r)')
plt.title(name+' radial wavefunctions')
plt.savefig('./Images/'+name+'-wave-functions.png')

with open('../Resources/fda/Atoms/'+name+'.out', 'r') as f:
    lines = f.readlines()

echo = 0
for line in lines:
     if echo == 1:
          print(line.strip())
     elif line.strip() == "Orbital Summary":
          print(name+' '+line.strip())
          echo = 1

#+End_SRC

#+RESULTS:
#+begin_example
He Orbital Summary
nl    occ        E           KE       <1/r>     <r>
1s   2.00      -0.8998      1.5175    1.7352   0.9133

Energy Summary
kinetic energy      =     3.0349
potential energy    =    -5.8876
one-electron energy =    -3.9058
two-electron energy =     1.0531

total energy =    -2.8527
virial ratio =    -1.9399
#+end_example

#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 0.4\textwidth
[[./Images/He-wave-functions.png]]


#+BEGIN_SRC python :exports results :results output
import matplotlib.pyplot as plt
import numpy as np
import os

# LITHIUM
L1 = ["300  0.0001  30.0\n"]
L2 = ["50 0.00001 0.10 0.50  0.682 0.0042\n"]
L3 = ["3.0 2\n"] # Z and number of states to compute
L4 = ["1 0 1.0 1.0\n"]  # n l up down
L5 = ["2 0 1.0 0.0\n"]  # n l up down
L = L1 + L2 + L3 + L4 + L5

name='Li'
radius=15

with open('../Resources/fda/Atoms/'+name+'.inp', 'w') as f:
     f.writelines(L)

os.system('../Resources/fda/fda ../Resources/fda/Atoms/'+name)

# Lets open the file in read mode
with open('../Resources/fda/Atoms/'+name+'.dmp', 'r') as f:

    # Reading all the lines in the file
    # Each line is stored as an element of a list
    lines = f.readlines()

    # First we read the grid points and the total charge densities
grid_points = []
total_charge_densities = []

for line in lines[3:302]:

     # Each is a string with two columns
     grid_point, tot_charge_density = line.split()

     # We need to convert each line to a float add it to our lists
     grid_points.append(float(grid_point))
     total_charge_densities.append(float(tot_charge_density))
    
# Now for the 1s orbital
one_s = []
one_s = [float(x) for x in lines[304:603]]
two_s = []
two_s = [float(x) for x in lines[605:904]] 

plt.figure()
#plt.semilogx(grid_points, total_charge_densities)
plt.plot(grid_points, total_charge_densities)
plt.xlabel('Grid Points')
plt.ylabel('Charge Density (electrons/bohr')
plt.title(name+' Radial Charge Density')
plt.xlim(0,radius)
plt.savefig('./Images/'+name+'-overall-charge-density.png')

plt.figure()
plt.plot(grid_points, one_s,label='1s')
plt.plot(grid_points, two_s,label='2s')
plt.legend()
plt.xlim(0,radius)

plt.xlabel('Distance (bohr)')
plt.ylabel('Wavefunction rR(r)')
plt.title(name+' radial wavefunctions')
plt.savefig('./Images/'+name+'-wave-functions.png')

with open('../Resources/fda/Atoms/'+name+'.out', 'r') as f:
    lines = f.readlines()

echo = 0
for line in lines:
     if echo == 1:
          print(line.strip())
     elif line.strip() == "Orbital Summary":
          print(name+' '+line.strip())
          echo = 1

#+END_SRC


#+RESULTS:
#+begin_example
Li Orbital Summary
nl    occ        E           KE       <1/r>     <r>
1s   2.00      -2.2989      3.9238    2.7994   0.5490
2s   1.00      -0.2044      0.2483    0.3695   3.7083

Energy Summary
kinetic energy      =     8.0959
potential energy    =   -15.4017
one-electron energy =    -9.8094
two-electron energy =     2.5036

total energy =    -7.3058
virial ratio =    -1.9024
#+end_example


#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 0.5\textwidth
[[./Images/Li-wave-functions.png]]


#+BEGIN_SRC python :exports results :results output
import matplotlib.pyplot as plt
import numpy as np
import os

# SODIUM
L1 = ["300  0.0001  30.0\n"]
L2 = ["50 0.00001 0.10 0.50  0.682 0.0042\n"]
L3 = ["11.0 4\n"] # Z and number of states to compute
L4 = ["1 0 1.0 1.0\n"]  # n l up down
L5 = ["2 0 1.0 1.0\n"]  # n l up down
L6 = ["2 1 3.0 3.0\n"]  # n l up down
L7 = ["3 0 1.0 0.0\n"]  # n l up down
L = L1 + L2 + L3 + L4 + L5 + L6 + L7

name='Na'
radius=15

with open('../Resources/fda/Atoms/'+name+'.inp', 'w') as f:
     f.writelines(L)

os.system('../Resources/fda/fda ../Resources/fda/Atoms/'+name)

# Lets open the file in read mode
with open('../Resources/fda/Atoms/'+name+'.dmp', 'r') as f:

    # Reading all the lines in the file
    # Each line is stored as an element of a list
    lines = f.readlines()

    # First we read the grid points and the total charge densities
grid_points = []
total_charge_densities = []

for line in lines[3:302]:

     # Each is a string with two columns
     grid_point, tot_charge_density = line.split()

     # We need to convert each line to a float add it to our lists
     grid_points.append(float(grid_point))
     total_charge_densities.append(float(tot_charge_density))
    
# Now for the 1s orbital
one_s = []
one_s = [float(x) for x in lines[304:603]]
two_s = []
two_s = [float(x) for x in lines[605:904]] 
two_p = []
two_p = [float(x) for x in lines[906:1205]] 
three_s = []
three_s = [float(x) for x in lines[1207:1506]] 

plt.figure()
#plt.semilogx(grid_points, total_charge_densities)
plt.plot(grid_points, total_charge_densities)
plt.xlabel('Grid Points')
plt.ylabel('Charge Density (electrons/bohr')
plt.title(name+' Radial Charge Density')
plt.xlim(0,radius)
plt.savefig('./Images/'+name+'-overall-charge-density.png')

plt.figure()
plt.plot(grid_points, one_s,label='1s')
plt.plot(grid_points, two_s,label='2s')
plt.plot(grid_points, two_p,label='2p')
plt.plot(grid_points, three_s,label='3s')
plt.legend()
plt.xlim(0,radius)

plt.xlabel('Distance (bohr)')
plt.ylabel('Wavefunction rR(r)')
plt.title(name+' radial wavefunctions')
plt.savefig('./Images/'+name+'-wave-functions.png')

with open('../Resources/fda/Atoms/'+name+'.out', 'r') as f:
    lines = f.readlines()

echo = 0
for line in lines:
     if echo == 1:
          print(line.strip())
     elif line.strip() == "Orbital Summary":
          print(name+' '+line.strip())
          echo = 1

#+END_SRC

#+RESULTS:
#+begin_example
Na Orbital Summary
nl    occ        E           KE       <1/r>     <r>
1s   2.00     -39.3997     57.1958   10.6955   0.1417
2s   2.00      -2.4534      7.2764    1.9224   0.7596
2p   6.00      -1.4174      6.5643    1.7927   0.7529
3s   1.00      -0.1925      0.3691    0.3310   3.9570

Energy Summary
kinetic energy      =   168.6993
potential energy    =  -330.3286
one-electron energy =  -230.8553
two-electron energy =    69.2261

total energy =  -161.6293
virial ratio =    -1.9581
#+end_example


#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 0.5\textwidth
[[./Images/Na-wave-functions.png]]


#+BEGIN_SRC python :exports results :results output
import matplotlib.pyplot as plt
import numpy as np
import os

# BORON
L1 = ["300  0.0001  30.0\n"]
L2 = ["50 0.00001 0.10 0.50  0.682 0.0042\n"]
L3 = ["5.0 3\n"] # Z and number of states to compute
L4 = ["1 0 1.0 1.0\n"]  # n l up down
L5 = ["2 0 1.0 1.0\n"]  # n l up down
L6 = ["2 1 1.0 0.0\n"]  # n l up down
L = L1 + L2 + L3 + L4 + L5 + L6 

name='B'
radius=15

with open('../Resources/fda/Atoms/'+name+'.inp', 'w') as f:
     f.writelines(L)

os.system('../Resources/fda/fda ../Resources/fda/Atoms/'+name)

# Lets open the file in read mode
with open('../Resources/fda/Atoms/'+name+'.dmp', 'r') as f:

    # Reading all the lines in the file
    # Each line is stored as an element of a list
    lines = f.readlines()

    # First we read the grid points and the total charge densities
grid_points = []
total_charge_densities = []

for line in lines[3:302]:

     # Each is a string with two columns
     grid_point, tot_charge_density = line.split()

     # We need to convert each line to a float add it to our lists
     grid_points.append(float(grid_point))
     total_charge_densities.append(float(tot_charge_density))
    
# Now for the 1s orbital
one_s = []
one_s = [float(x) for x in lines[304:603]]
two_s = []
two_s = [float(x) for x in lines[605:904]] 
two_p = []
two_p = [float(x) for x in lines[906:1205]] 

plt.figure()
#plt.semilogx(grid_points, total_charge_densities)
plt.plot(grid_points, total_charge_densities)
plt.xlabel('Grid Points')
plt.ylabel('Charge Density (electrons/bohr')
plt.title(name+' Radial Charge Density')
plt.xlim(0,radius)
plt.savefig('./Images/'+name+'-overall-charge-density.png')

plt.figure()
plt.plot(grid_points, one_s,label='1s')
plt.plot(grid_points, two_s,label='2s')
plt.plot(grid_points, two_p,label='2p')
plt.legend()
plt.xlim(0,radius)

plt.xlabel('Distance (bohr)')
plt.ylabel('Wavefunction rR(r)')
plt.title(name+' radial wavefunctions')
plt.savefig('./Images/'+name+'-wave-functions.png')

with open('../Resources/fda/Atoms/'+name+'.out', 'r') as f:
    lines = f.readlines()

echo = 0
for line in lines:
     if echo == 1:
          print(line.strip())
     elif line.strip() == "Orbital Summary":
          print(name+' '+line.strip())
          echo = 1

#+END_SRC

#+RESULTS:
#+begin_example
B Orbital Summary
nl    occ        E           KE       <1/r>     <r>
1s   2.00      -7.3382     11.3935    4.7725   0.3195
2s   2.00      -0.4862      1.1651    0.7749   1.8633
2p   1.00      -0.2627      0.8572    0.6432   2.1503

Energy Summary
kinetic energy      =    25.9745
potential energy    =   -50.2880
one-electron energy =   -32.7155
two-electron energy =     8.4020

total energy =   -24.3135
virial ratio =    -1.9361
#+end_example


#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 0.5\textwidth
[[./Images/B-wave-functions.png]]



#+BEGIN_SRC python :exports results :results output
import matplotlib.pyplot as plt
import numpy as np
import os

# CARBON
L1 = ["300  0.0001  30.0\n"]
L2 = ["50 0.00001 0.10 0.50  0.682 0.0042\n"]
L3 = ["6.0 3\n"] # Z and number of states to compute
L4 = ["1 0 1.0 1.0\n"]  # n l up down
L5 = ["2 0 1.0 1.0\n"]  # n l up down
L6 = ["2 1 2.0 0.0\n"]  # n l up down
L = L1 + L2 + L3 + L4 + L5 + L6 

name='C'
radius=15

with open('../Resources/fda/Atoms/'+name+'.inp', 'w') as f:
     f.writelines(L)

os.system('../Resources/fda/fda ../Resources/fda/Atoms/'+name)

# Lets open the file in read mode
with open('../Resources/fda/Atoms/'+name+'.dmp', 'r') as f:

    # Reading all the lines in the file
    # Each line is stored as an element of a list
    lines = f.readlines()

    # First we read the grid points and the total charge densities
grid_points = []
total_charge_densities = []

for line in lines[3:302]:

     # Each is a string with two columns
     grid_point, tot_charge_density = line.split()

     # We need to convert each line to a float add it to our lists
     grid_points.append(float(grid_point))
     total_charge_densities.append(float(tot_charge_density))
    
# Now for the 1s orbital
one_s = []
one_s = [float(x) for x in lines[304:603]]
two_s = []
two_s = [float(x) for x in lines[605:904]] 
two_p = []
two_p = [float(x) for x in lines[906:1205]] 

plt.figure()
#plt.semilogx(grid_points, total_charge_densities)
plt.plot(grid_points, total_charge_densities)
plt.xlabel('Grid Points')
plt.ylabel('Charge Density (electrons/bohr')
plt.title(name+' Radial Charge Density')
plt.xlim(0,radius)
plt.savefig('./Images/'+name+'-overall-charge-density.png')

plt.figure()
plt.plot(grid_points, one_s,label='1s')
plt.plot(grid_points, two_s,label='2s')
plt.plot(grid_points, two_p,label='2p')
plt.legend()
plt.xlim(0,radius)

plt.xlabel('Distance (bohr)')
plt.ylabel('Wavefunction rR(r)')
plt.title(name+' radial wavefunctions')
plt.savefig('./Images/'+name+'-wave-functions.png')

with open('../Resources/fda/Atoms/'+name+'.out', 'r') as f:
    lines = f.readlines()

echo = 0
for line in lines:
     if echo == 1:
          print(line.strip())
     elif line.strip() == "Orbital Summary":
          print(name+' '+line.strip())
          echo = 1

#+END_SRC

#+RESULTS:
#+begin_example
C Orbital Summary
nl    occ        E           KE       <1/r>     <r>
1s   2.00     -10.8710     16.5840    5.7583   0.2643
2s   2.00      -0.6769      1.8255    0.9670   1.5010
2p   2.00      -0.3555      1.4282    0.8313   1.6628

Energy Summary
kinetic energy      =    39.6755
potential energy    =   -77.0810
one-electron energy =   -51.0043
two-electron energy =    13.5987

total energy =   -37.4055
virial ratio =    -1.9428
#+end_example


#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 0.5\textwidth
[[./Images/C-wave-functions.png]]


#+BEGIN_SRC python :exports results :results output
import matplotlib.pyplot as plt
import numpy as np
import os

# NITROGEN
L1 = ["300  0.0001  30.0\n"]
L2 = ["50 0.00001 0.10 0.50  0.682 0.0042\n"]
L3 = ["7.0 3\n"] # Z and number of states to compute
L4 = ["1 0 1.0 1.0\n"]  # n l up down
L5 = ["2 0 1.0 1.0\n"]  # n l up down
L6 = ["2 1 3.0 0.0\n"]  # n l up down
L = L1 + L2 + L3 + L4 + L5 + L6 

name='N'
radius=15

with open('../Resources/fda/Atoms/'+name+'.inp', 'w') as f:
     f.writelines(L)

os.system('../Resources/fda/fda ../Resources/fda/Atoms/'+name)

# Lets open the file in read mode
with open('../Resources/fda/Atoms/'+name+'.dmp', 'r') as f:

    # Reading all the lines in the file
    # Each line is stored as an element of a list
    lines = f.readlines()

    # First we read the grid points and the total charge densities
grid_points = []
total_charge_densities = []

for line in lines[3:302]:

     # Each is a string with two columns
     grid_point, tot_charge_density = line.split()

     # We need to convert each line to a float add it to our lists
     grid_points.append(float(grid_point))
     total_charge_densities.append(float(tot_charge_density))
    
# Now for the 1s orbital
one_s = []
one_s = [float(x) for x in lines[304:603]]
two_s = []
two_s = [float(x) for x in lines[605:904]] 
two_p = []
two_p = [float(x) for x in lines[906:1205]] 

plt.figure()
#plt.semilogx(grid_points, total_charge_densities)
plt.plot(grid_points, total_charge_densities)
plt.xlabel('Grid Points')
plt.ylabel('Charge Density (electrons/bohr')
plt.title(name+' Radial Charge Density')
plt.xlim(0,radius)
plt.savefig('./Images/'+name+'-overall-charge-density.png')

plt.figure()
plt.plot(grid_points, one_s,label='1s')
plt.plot(grid_points, two_s,label='2s')
plt.plot(grid_points, two_p,label='2p')
plt.legend()
plt.xlim(0,radius)

plt.xlabel('Distance (bohr)')
plt.ylabel('Wavefunction rR(r)')
plt.title(name+' radial wavefunctions')
plt.savefig('./Images/'+name+'-wave-functions.png')

with open('../Resources/fda/Atoms/'+name+'.out', 'r') as f:
    lines = f.readlines()

echo = 0
for line in lines:
     if echo == 1:
          print(line.strip())
     elif line.strip() == "Orbital Summary":
          print(name+' '+line.strip())
          echo = 1

#+END_SRC

#+RESULTS:
#+begin_example
N Orbital Summary
nl    occ        E           KE       <1/r>     <r>
1s   2.00     -15.0801     22.7490    6.7446   0.2254
2s   2.00      -0.8883      2.5980    1.1518   1.2645
2p   3.00      -0.4550      2.1076    1.0101   1.3691

Energy Summary
kinetic energy      =    57.0168
potential energy    =  -111.0407
one-electron energy =   -74.7460
two-electron energy =    20.7221

total energy =   -54.0239
virial ratio =    -1.9475
#+end_example


#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 0.5\textwidth
[[./Images/N-wave-functions.png]]


#+BEGIN_SRC python :exports results :results output
import matplotlib.pyplot as plt
import numpy as np
import os

# OXYGEN
L1 = ["300  0.0001  30.0\n"]
L2 = ["50 0.00001 0.10 0.50  0.682 0.0042\n"]
L3 = ["8.0 3\n"] # Z and number of states to compute
L4 = ["1 0 1.0 1.0\n"]  # n l up down
L5 = ["2 0 1.0 1.0\n"]  # n l up down
L6 = ["2 1 3.0 1.0\n"]  # n l up down
L = L1 + L2 + L3 + L4 + L5 + L6 

name='O'
radius=15

with open('../Resources/fda/Atoms/'+name+'.inp', 'w') as f:
     f.writelines(L)

os.system('../Resources/fda/fda ../Resources/fda/Atoms/'+name)

# Lets open the file in read mode
with open('../Resources/fda/Atoms/'+name+'.dmp', 'r') as f:

    # Reading all the lines in the file
    # Each line is stored as an element of a list
    lines = f.readlines()

    # First we read the grid points and the total charge densities
grid_points = []
total_charge_densities = []

for line in lines[3:302]:

     # Each is a string with two columns
     grid_point, tot_charge_density = line.split()

     # We need to convert each line to a float add it to our lists
     grid_points.append(float(grid_point))
     total_charge_densities.append(float(tot_charge_density))
    
# Now for the 1s orbital
one_s = []
one_s = [float(x) for x in lines[304:603]]
two_s = []
two_s = [float(x) for x in lines[605:904]] 
two_p = []
two_p = [float(x) for x in lines[906:1205]] 

plt.figure()
#plt.semilogx(grid_points, total_charge_densities)
plt.plot(grid_points, total_charge_densities)
plt.xlabel('Grid Points')
plt.ylabel('Charge Density (electrons/bohr')
plt.title(name+' Radial Charge Density')
plt.xlim(0,radius)
plt.savefig('./Images/'+name+'-overall-charge-density.png')

plt.figure()
plt.plot(grid_points, one_s,label='1s')
plt.plot(grid_points, two_s,label='2s')
plt.plot(grid_points, two_p,label='2p')
plt.legend()
plt.xlim(0,radius)

plt.xlabel('Distance (bohr)')
plt.ylabel('Wavefunction rR(r)')
plt.title(name+' radial wavefunctions')
plt.savefig('./Images/'+name+'-wave-functions.png')

with open('../Resources/fda/Atoms/'+name+'.out', 'r') as f:
    lines = f.readlines()

echo = 0
for line in lines:
     if echo == 1:
          print(line.strip())
     elif line.strip() == "Orbital Summary":
          print(name+' '+line.strip())
          echo = 1

#+END_SRC

#+RESULTS:
#+begin_example
O Orbital Summary
nl    occ        E           KE       <1/r>     <r>
1s   2.00     -19.9695     29.8903    7.7313   0.1964
2s   2.00      -1.1208      3.4852    1.3328   1.0956
2p   4.00      -0.5609      2.8966    1.1841   1.1696

Energy Summary
kinetic energy      =    78.3376
potential energy    =  -152.8395
one-electron energy =  -104.5798
two-electron energy =    30.0778

total energy =   -74.5019
virial ratio =    -1.9510
#+end_example


#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 0.5\textwidth
[[./Images/O-wave-functions.png]]


#+BEGIN_SRC python :exports results :results output
import matplotlib.pyplot as plt
import numpy as np
import os

# NEEDS TO BE FIXED
# Argon
L1 = ["300  0.0001  30.0\n"]
L2 = ["50 0.00001 0.10 0.50  0.682 0.0042\n"]
L3 = ["18.0 5\n"] # Z and number of states to compute
L4 = ["1 0 1.0 1.0\n"]  # n l up down
L5 = ["2 0 1.0 1.0\n"]  # n l up down
L6 = ["2 1 3.0 3.0\n"]  # n l up down
L7 = ["3 0 1.0 1.0\n"]  # n l up down
L8 = ["3 1 3.0 3.0\n"]  # n l up down
L = L1 + L2 + L3 + L4 + L5 + L6 + L7 + L8

name='Ar'
radius=15

with open('../Resources/fda/Atoms/'+name+'.inp', 'w') as f:
     f.writelines(L)

os.system('../Resources/fda/fda ../Resources/fda/Atoms/'+name)

# Lets open the file in read mode
with open('../Resources/fda/Atoms/'+name+'.dmp', 'r') as f:

    # Reading all the lines in the file
    # Each line is stored as an element of a list
     lines = f.readlines()

    # First we read the grid points and the total charge densities
grid_points = []
total_charge_densities = []

for line in lines[3:303]:

     # Each is a string with two columns
     grid_point, tot_charge_density = line.split()

     # We need to convert each line to a float add it to our lists
     grid_points.append(float(grid_point))
     total_charge_densities.append(float(tot_charge_density))
    
# Now for the 1s orbital
one_s = []
one_s = [float(x) for x in lines[304:604]]
 

plt.figure()
#plt.semilogx(grid_points, total_charge_densities)
plt.plot(grid_points, total_charge_densities)
plt.xlabel('Grid Points')
plt.ylabel('Charge Density (electrons/bohr')
plt.title(name+' Radial Charge Density')
plt.xlim(0,radius)
plt.savefig('./Images/'+name+'-overall-charge-density.png')

plt.figure()
plt.plot(grid_points, one_s,label='1s')
plt.legend()
plt.xlim(0,radius)

plt.xlabel('Distance (bohr)')
plt.ylabel('Wavefunction rR(r)')
plt.title(name+' radial wavefunctions')
plt.savefig('./Images/'+name+'-wave-functions.png')

with open('../Resources/fda/Atoms/'+name+'.out', 'r') as f:
    lines = f.readlines()

echo = 0
for line in lines:
     if echo == 1:
          print(line.strip())
     elif line.strip() == "Orbital Summary":
          print(name+' '+line.strip())
          echo = 1

#+END_SRC


#+BEGIN_EXPORT latex
\begin{table}[]
   \caption{Numerical DFT Solutions for Atoms }
\begin{tabular}{cc}
\includegraphics[scale=0.33]{Images/Slide1.png} & \includegraphics[scale=0.33]{Images/Slide2.png} \\
\includegraphics[scale=0.33]{Images/Slide3.png} & \includegraphics[scale=0.33]{Images/Slide4.png} \\
\includegraphics[scale=0.33]{Images/Slide5.png} & \includegraphics[scale=0.5]{Images/Ionization.png} 
\end{tabular}
\end{table}
#+END_EXPORT

** Lecture 13: Qualitative models of bonding
*** Qualtitative bonding
1. What does a molecule (or a solid) have that an atom doesn't?...more nuclei!
2. Why might those atoms clump together to form molecules or solids?...tunneling! Electrons are happier (lower in energy) when they can wander out of their local potential well
3. Recall particle in a finite well. What matters?  Depths of wells and distance between them.
*** Clamped nucleus ("Born-Oppenheimer") approximation
1. Write one-electron equations parametrically in terms of positions of  all atoms
      \begin{eqnarray}
      \hat h & = & -\frac{\hbar^2}{2m_e}\nabla^2-\sum_\alpha \frac{Z_\alpha
          e^2}{4\pi\epsilon_0}\frac{1}{|{\bf r}-{\bf R}_\alpha|} \\
      \hat f\psi & = & \left\{\hat h + \hat v_\mathrm{Coul}[\psi_i] + \hat
            v_\mathrm{ex}[\psi_i]+\hat v_\mathrm{corr}[\psi_i] \right\}\psi=\epsilon\psi
      \end{eqnarray}
2. Solve as for atoms, using some model for electron-electron interactions
3. Potential energy surface (PES)
	\[ E({\bf R}_\alpha, {\bf
            R}_\beta,...)=E_\mathrm{elec}+\frac{e^2}{4\pi\epsilon_0}\sum_\alpha\sum_{\beta>\alpha}\frac{Z_\alpha
            Z_\beta}{|{\bf R}_\alpha-{\bf R}_\beta|} \]
*** H$_2$ molecule as perturbation on two H atoms brought from infinite distance
1. "Bonding" orbital, \(\sigma_g({\bf r}) = 1{\rm s_A}+1{\rm s_B}\)
2. "Anti-bonding" orbital, $\sigma_u({\bf r}) = 1{\rm s_A}-1{\rm s_B}$
3. Interaction scales with "overlap" $S = \langle 1{\rm s_A} | 1{\rm
            s_B} \rangle$
4. Normalize
     \begin{displaymath}
     \sigma_g = \frac{1}{\sqrt{2(1-S)}}\left ( 1{\rm s_A}+1{\rm s_B} \right)     \quad\quad
     \sigma_u = \frac{1}{\sqrt{2(1+S)}}\left ( 1{\rm s_A}-1{\rm s_B} \right)
     \end{displaymath}
5. Energy expectation value
     \begin{eqnarray*}
     \epsilon_g = \langle \sigma_g | \hat{f} | \sigma_g \rangle & = & \frac{1}{2(1+S)} \left \{ \langle 1{\rm s_A} | \hat{f} | 1{\rm s_A} \rangle +  \langle 1{\rm s_B} | \hat{f} | 1{\rm s_B} \rangle + 2 \langle 1{\rm s_A} | \hat{f} |1{\rm s_B} \rangle \right \}\\
     & = & \frac{1}{1+S} \left ( F_{\rm AA} + F_{\rm AB} \right ) \\
     \epsilon_u = \langle \sigma_u | \hat{f} | \sigma_u \rangle & = & \frac{1}{2(1+S)} \left \{ \langle 1{\rm s_A} | \hat{f} | 1{\rm s_A} \rangle + \langle 1{\rm s_B} | \hat{f} | 1{\rm s_B} \rangle - 2 \langle 1{\rm s_A} | \hat{f} | 1{\rm s_B} \rangle\right \}\\
     & = & \frac{1}{1-S} \left ( F_{\rm AA} - F_{\rm AB} \right )
     \end{eqnarray*}
6. Matrix elements
      \begin{eqnarray*}
	F_{\rm AA}=F_{\rm BB}\approx \epsilon_{1\mathrm{s}}=\alpha \\
	F_{\rm AB}=F_{\rm BA}=\beta \\
	\alpha < \beta < 0\ \ \mathrm{typically}
      \end{eqnarray*}
      \begin{center}
      \includegraphics[scale=0.5]{./Images/H2-MO}       
      \end{center}
7. From Taylor expansion get picture of atomic orbitals destabilized by electron repulsion $\beta S$ and split by interaction $\beta$
      \begin{eqnarray*}
	\epsilon_+\approx \alpha-\beta S + \beta \\
	\epsilon_-\approx \alpha - \beta S - \beta
      \end{eqnarray*}
8. Makes clear that bonding stabilization $<$ anti-bonding destabilization
9. Ground configuration $=\sigma_g^2$
10. Bond order = $\frac{1}{2}(n-n^*)$
11. Electron-driven bonding in competetition with $1/R$ repulsion between nuclei.

#+BEGIN_SRC python :exports results :results output
import matplotlib.pyplot as plt
import numpy as np

def Morse(R):
    return A*((1-np.exp(-alpha*(R - R0)))**2-1)

R0 = 1
alpha = 1
A = 1

R = np.linspace(R0/300,8*R0,100)
V = Morse(R)

plt.figure()
plt.plot(R,V)
plt.plot([0,8*R0],[0,0],ls='--', color = 'black')
plt.xlabel('Interatomic distance (au)')
plt.ylabel('Potential energy (au)')
plt.title('Qualitative PES for diatomic molecule')
plt.savefig('./Images/Morse.png')
#+END_SRC

#+RESULTS:

#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 0.5\textwidth
[[./Images/Morse.png]]

*** Heteronuclear diatomic: LiH, HF, BH example
1. Only AOs of appropriate symmetry, overlap, and energy match can combine to form MOs
      \begin{eqnarray*}
	\epsilon_+\approx \alpha_1- \beta S  - \beta^2/|\alpha_1-\alpha_2| \\
	\epsilon_-\approx \alpha_2 - \beta S + \beta^2/|\alpha_1-\alpha_2|
      \end{eqnarray*}
2. LiH: H 1s + Li 2s, bond polarized towards H
3. HF: H 1s + F 2p, bond polarized towards F, lots of non-bonding orbitals
4. BH: H 1s, B 2s and 2p$_z \rightarrow$ bonding, non-bonding, anti-bonding orbitals
*** Homonuclear diatomic: O$_2$
1. Assign aos, 1s, 2s, 2p for each atom (10 total)
2. In principle, solve $10\times 10$ secular matrix
3. In practice, matrix elements rules mean only a few off-diagonal elements survive
   1. 1s + 1s do nothing
   2. 2s + 2s form $\sigma$ bond and anti-bond
   3. 2p$_z$ + 2p$_z$ form second bond and anti-bond
   4. 2p$_{x,y}$ + 2p$_{x,y}$ form degenerate $\pi$ bonds and anti-bonds
   5. O$_2$ is a triplet, consistent with experiment!
*** COMMENT Secular equations
1. Expand wavefunctions ("molecular orbitals") in "basis" of atomic-like orbitals
	\begin{equation}
          \psi_\mathrm{MO}=\sum_a c_a\phi_a({\bf r})
	\end{equation}
2. Problem reduces to finding set of $c_a$ that give best wavefunctions (MOs)
3. Substituting into Schr\ouml{}dinger equation and integrating yields set of linear equations for the $c_a$ for each MO
	\begin{displaymath}
          \left ( \begin{array}{ccc}
            F_{11}-\epsilon S_{11} & F_{12}-\epsilon S_{12} & \ldots \\
            F_{21}-\epsilon S_{21} & F_{22}-\epsilon S_{22} & \ldots \\
            \vdots & \vdots & \vdots
          \end{array} \right ) \left (
          \begin{array}{c}
            c_1 \\
            c_2 \\
            \vdots
          \end{array} \right ) = 0
      \end{displaymath}
   1. $F_{ij} = F_{ji} = \langle \phi_i | \hat f | \phi_j \rangle$ are
	``matrix elements''
   2. $S_{ij} = S_{ji} = \langle \phi_i | \phi_j \rangle$ are overlaps
   3. Typically basis functions normalized such that $S_{ii} = 1$
   4. $\epsilon$ are molecular orbital energies (to be solved for, as many as there are equations)
4. From linear algebra, only possible solutions are those that make the determinant vanish
	\begin{displaymath}
          \left | \begin{array}{ccc}
            F_{11}-\epsilon S_{11} & F_{12}-\epsilon S_{12} & \ldots \\
            F_{21}-\epsilon S_{21} & F_{22}-\epsilon S_{22} & \ldots \\
            \vdots & \vdots & \vdots
          \end{array} \right | = 0
      \end{displaymath}
5. Solve for \(\epsilon\)s and back-substitute to find correspond \(c_i\)s
*** COMMENT H$_2$ example, again
1. Set-up and solve secular matrix
      \begin{displaymath}
       \left | \begin{array}{cc}
           \alpha-\epsilon & \beta-\epsilon S \\
           \beta - \epsilon S & \alpha-\epsilon
           \end{array} \right | = 0
      \end{displaymath}
      \begin{eqnarray*}
	\epsilon_+=\frac{\alpha+\beta}{1+S},\ \ c_1=c_2=\frac{1}{\sqrt{2(1+S)}} \\
	\epsilon_-=\frac{\alpha-\beta}{1-S},\ \ c_1=-c_2=\frac{1}{\sqrt{2(1-S)}} \\
      \end{eqnarray*}
*** COMMENT Qualitative solutions of secular equations
1. Lot's of insight into chemical bonding can be obtained from approximate solutions to secular equations, basis of "molecular orbital theory"
2. Two general assumptions
   1. Diagonal matrix elements are approximately equal to energies of corresponding atomic orbitals: $F_{ii} \approx \epsilon_{i,\mathrm{ao}}$
   2. Off-diagonal elements proportional to overlap and inversely proportional to energy difference:
	\begin{displaymath}
          F_{ij} \propto \frac{S_{ij}}{\epsilon_{i,\mathrm{ao}}-\epsilon_{j,\mathrm{ao}}}
	\end{displaymath}
   3. (Often) set differential overlap $S_{ij}=0$

*** The H\uuml{}ckel/#+title: 
ght binding model: [[http://resolver.caltech.edu/CaltechBOOK:1961.001][Roberts, Notes on Molecular Orbital Theory]]
1. $F_{ii}=\alpha, S_{ij}=\delta_{ij}, F_{ij}=\beta$ iff $i$ adjacent to $j$
2. Ethylene example
3. Butadiene example
4. Benzene example
5. Infinite chain example

#+BEGIN_SRC python :exports results :results output org drawer
from sympy import *
init_printing(use_unicode=True)

print('Huckel model for pi orbitals of cyclobutadiene\n')
alpha,beta = symbols('alpha beta')

M = Matrix([[alpha, beta, 0 , beta],[beta, alpha, beta, 0],[0,beta,alpha,beta],[beta,0,beta,alpha]])

pprint(M)
# M = Matrix([[alpha,beta],[beta,alpha]])

eigs  = M.eigenvects()

pprint("\nEnergy state, degeneracy\n")
for state in [0, 1, 2]:
    print('{0}    {1}\n'.format(eigs[state][0],eigs[state][1]))

pprint("\nEigenvectors")
for state in [2,1,0]:
    print("Eigenvector(s) of state",state,":",eigs[state][2])
    print(" ")

#+END_SRC

#+RESULTS:
:results:
Huckel model for pi orbitals of cyclobutadiene

⎡α  β  0  β⎤
⎢          ⎥
⎢β  α  β  0⎥
⎢          ⎥
⎢0  β  α  β⎥
⎢          ⎥
⎣β  0  β  α⎦
                        
Energy state, degeneracy
alpha    2

alpha - 2*beta    1

alpha + 2*beta    1

            
Eigenvectors
Eigenvector(s) of state 2 : [Matrix([
[1],
[1],
[1],
[1]])]
 
Eigenvector(s) of state 1 : [Matrix([
[-1],
[ 1],
[-1],
[ 1]])]
 
Eigenvector(s) of state 0 : [Matrix([
[-1],
[ 0],
[ 1],
[ 0]]), Matrix([
[ 0],
[-1],
[ 0],
[ 1]])]
 
:end:

#+ATTR_LATEX: :width 0.8\textwidth
[[./Images/CyclicH.pdf]]

*** Band structure of solids  
1. Discrete molecular orbitals transform into continuous bands
2. Results in rich range of physical and chemical properties

#+ATTR_LATEX: :width 0.9\textwidth
[[./Images/band.pdf]]

*** Non-bonding interactions
1. Chemical covalent bonds have energies on the order of several eV
2. Even things that are not "bonded" still attract one another
   1. permanent dipoles (~0.1 eV)
   2. induced dipoles (dispersion)---scales with number of electrons
3. Results in physical properties, eg trends in boiling point (He < Ne < Kr < Xe; \ce{CH4} < \ce{C2H6} < \ce{C3H8} )
** Lecture 14: Quantitative Models of Bonding
*** Numerical Schr\ouml{}dinger equation solvers for discrete (molecule) and periodic (solids/liquids/interfaces) readily available today
*** Have to specify:
   1. Identity of atoms
   2. Positions of atoms (distances, angles, $\ldots$)
   3. (spin multiplicity)
   4. exact theoretical model (how are Coulomb, exchange, and correlation described?)
      1. Hartree, Hartree-Fock, DFT (various flavors), $\ldots$
   5. basis set to express wavefunctions in terms of
   6. initial guess of wavefunction coefficients (often guessed for you)
*** Secular equations solved iteratively until input coefficients = output coefficients
1. "self-consistent field"
2. Output
   1. energies of molecular orbitals
   2. occupancies of molecular orbitals
   3. coefficients describing molecular orbitals
   4. total electron wavefunction, total electron density, dipole moment, $\ldots$
   5. total molecular energy
   6. derivatives ("gradients") of total energy w.r.t. atom positions
3. Plot total energy vs internal coordinates: potential energy surface (PES)
4. Search iteratively for minimum point on PES (by hand or using gradient-driven search): equilibrium geometry
5. Find second derivative of energy at minimum point on PES: harmonic vibrational frequency
6. Find energy at minimum relative to atoms (or other molecules): reaction energy
*** H$_2$ example
1. Choose "B3LYP" model for Coulomb, exchange, and correlation potentials
2. Choose "6-31G(d)" basis set
3. Compute total energy vs distance
4. Fit energies to quadratic near minimum
5. Predict minimum from fit
6. Extract harmonic force constant \(k\) from second derivative of fit
7. Compute harmonic frequency from force constant
8. Compute zero point vibrational energy from frequency, ZPE \(=0.5 h\nu\).

#+BEGIN_COMMENT

     \begin{center}
       \includegraphics[scale=0.6]{Images/H2-PES}
     \end{center}

|---------+-------------------|
| R (Ang) | B3LYP Energy (eV) |
|---------+-------------------|
|    0.60 |    -31.2805083454 |
|    0.65 |    -31.6084683599 |
|    0.70 |    -31.7670982175 |
|    0.75 |    -31.8034421873 |
|    0.80 |    -31.7513617995 |
|    0.85 |    -31.6355793258 |
|    0.90 |    -31.4743364948 |
|---------+-------------------|
#+END_COMMENT

#+BEGIN_SRC python :exports results :results output
import matplotlib.pyplot as plt
import numpy as np
from numpy.polynomial import polynomial as P

HeV = 27.212 # eV/Hartree
a0 = 0.529177 # Angstrom/bohr
h = 4.12566e-15 # eV s
c = 2.998e8 # m/s
massH = 9.389458e8 # eV / c^2

def quad(x,c):
    return c[0]+x*(c[1]+x*c[2])

R = [0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9]
E = HeV * np.array( [-1.149512, -1.16156358812, -1.16739299638, -1.16872858251,  -1.16681470673, -1.16255987527, -1.15663444417])

plt.figure()
plt.plot(R, E, 'o')
plt.xlabel('Interatomic distance (Angstrom)')
plt.ylabel('Potential energy (eV)')
plt.title('Quantitative H2 PES (B3LYP)')

# Create quadratic fit of points nearest minimum
xfit = R[1:5]
yfit = E[1:5]
coef, stats = P.polyfit(xfit,yfit,2,full=True)
# print(coef)
# print(stats)

x = np.linspace(R[0],R[6],100)
y = quad(x,coef)

rmin = -coef[1]/(2.*coef[2])
rmin_expt=0.742       # Ang
emin=quad(rmin,coef)     # eV

plt.plot(x,y,'-',label='{0:5.3f}x^2+{1:5.3f}x+{2:5.3f}'.format(coef[2],coef[1],coef[0]))


# harmonic frequency
k = 2*coef[2]            # eV/Ang^2
muH2 = massH/2     # eV / c^2
nu = (1/(2*np.pi))*np.sqrt(k/muH2)  # c/Ang
nu = nu * c / 1e-10   # /s
nutilde = nu/c /100  # /cm
nutilde_expt = 4401.
ZPE = 0.5*h*nu

plt.plot([R[0],R[6]],[ZPE+emin,ZPE+emin],ls='-',color='red',label='ZPE')
plt.legend()
plt.savefig('./Images/H2-B3LYP.png')

EHB3LYP = -0.4969*HeV
Edissoc = 2*EHB3LYP-(emin+ZPE)
Edissoc_expt = 4.478

print('     -----------------------------------')
print('                       B3LYP       EXPT')
print('     -----------------------------------')
print('     H-H     (Ang):    {0:5.3f}       {1:5.3f}'.format(rmin,rmin_expt))
print('     nu~    (cm-1):  {0:6.0f}      {1:6.0f}'.format(nutilde,nutilde_expt))
print()
print('     E H2     (eV):   {0:5.2f}                '.format(emin))
print('     ZPE H2   (eV):    {0:5.2f}'.format(ZPE))
print('     2*E H    (eV):   {0:5.2f}                '.format(2*EHB3LYP))
print('                       -----                  ')
print('     E Dissoc (eV):    {0:5.2f}       {1:5.2f}'.format(Edissoc,Edissoc_expt))
print('     -----------------------------------')

#print('B3LYP H-H: {0:5.3f}'.format(min))

#+END_SRC

#+RESULTS:
#+begin_example
     -----------------------------------
                       B3LYP       EXPT
     -----------------------------------
     H-H     (Ang):    0.747       0.742
     nu~    (cm-1):    4768        4401

     E H2     (eV):   -31.81                
     ZPE H2   (eV):     0.29
     2*E H    (eV):   -27.04                
                       -----                  
     E Dissoc (eV):     4.47        4.48
     -----------------------------------
#+end_example

#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 0.7\textwidth
[[./Images/H2-B3LYP.png]]

*** Polyatomic molecules
1. Gradient-driven optimizations, $3n-6$ degrees of freedom
2. Hessian matrix for frequencies
3. [[https://cccbdb.nist.gov/][Computational Chemistry Comparison and Benchmark Database]]
*** Solids
1. [[https://next-gen.materialsproject.org/][Materials project]]
2. [[https://oqmd.org/][OQMD]]
** COMMENT Lecture 15: Electronic spectroscopy
*** Electronic spectroscopy probes electron jumps between energy states, or "orbitals"
1. The electronic structure of each substance is unique, so no general energy expression for electronic transitions
2. Core, valence, virtual, vacuum states
3.  Transitions approximately difference between orbital energies (Koopman's theorem)
  \[h \nu \approx \epsilon_\mathrm{final}-\epsilon_\mathrm{initial} \]
4. This "theorem" is an approximation because the orbitals are not static; more correctly, the energy difference is given by a full electronic structure calculation on the initial and final states

*** Selection Rules
1. $\Delta S = 0$ "allowed"
2. $\Delta S \ne 0$ "forbidden"

*** Classes of transitions
**** UV/visible spectroscopy
 1. electron jumps from valence filled to empty orbital
 2. energies of an eV or so
 3. $\pi$ to $\pi^*$ classic example
**** UV photoelectron spectroscopy
 1. electron ionized from valence filled orbital
 2. 10's of eVs
**** X-ray spectroscopy
 1. electron ionized from core orbital or promoted from core to an empty orbital 
 2. 100's-1000's eV energies
 3. many types, from lab scale to massive synchrotrons
 4. information about elemental composition, oxidation state, coordination, ...          
**** Stimulated absorption
 1. photon causes jump from lower to higher energy electronic state
 2. often convoluted with jumps to different vibrational, rotational states          
**** Spontaneous emission
 1. electron spontaneously drops to a lower energy state and emits a photon
 2. basis of fluorescence ($\Delta S = 0$)
 3. basis of long-lived phosphorescence ($\Delta S \neq  0$)
 4. long-lived because it breaks the spin selection rule
**** Stimulated emission
 1. passing photon causes electron to jump from higher to a lower energy state and to emit another photon
 2. cascade of such stimulated events is the basis of laser action#+BEGIN_COMMENT
** COMMENT Lecture 16: Electronic and magnetic properties

* Statistical Mechanics: The Bridge from the Tiny to the Many
** Lecture 17: Statistical mechanics
*** Need machinary to average QM information over macroscopic systems
*** Equal /a priori/ probabilities
1. Any way to distribute energy amongst elements of a system are as likely as any other
*** Two-state model
1. Box of particles, each of which can have energy 0 or $\epsilon$
2. Thermodynamic state defined by number of elements $N$, and number of quanta $q$, $U=q\epsilon$
3. Degeneracy of given $N$ and $q$ given by binomial distribution:
        \begin{displaymath}
          \Omega(N,q)=\frac{N!}{q!(N-q)!}
        \end{displaymath}
4. Allow energy (heat!) to exchange between two such systems
   1. Energy of composite system is sum of individual systems (first law, \(q_1+q_2=q\))
   2. Degeneracy of composite system is always $\geq$ degeneracy of the starting parts!
          \[\Omega(N_1+N_2,q_1+q_2) > \Omega(N_1,q_1)\cdot \Omega(N_2,q_2) \]
   3. Boltzmann's tombstone, $S = k_B \ln \Omega$
   4. Second Law:
#+BEGIN_QUOTE
Die Energie der Welt ist constant.  Die Entropie der Welt strebt einem Maximum zu. - Clausius
#+END_QUOTE

*** Large two-state system
1. Stirling's approximation:
     \[\Omega(N,q) \approx N^N/(N-q)^{(N-q)}\]
2. Composite system
     \[\Omega(N,q) = \sum_{i\le q} \Omega(N_1,i)\cdot \Omega(N_2,q-i) \]
3. For large $N$, one term /overwhelmingly/ dominates sum
#+BEGIN_SRC python :exports results :results output
import numpy as np
import matplotlib.pyplot as plt

def Omega(N,q):
    return (N**N)/((N-q)**(N-q))
def LOmega(N,q):
    return N*np.log(N)-(N-q)*np.log(N-q)

plt.figure()
N1 = 100
N2 = 100
qtot = 50
q1=np.linspace(0,qtot,qtot+1)
q2 = qtot - q1

lomega1 = LOmega(N1,q1)
lomega2 = LOmega(N2,q2)

plt.subplot(1,2,1)
plt.plot(q1,lomega1,label="System 1")
plt.plot(q1,lomega2,label="System 2")
composite=lomega1+lomega2
plt.plot(q1,composite,label="Composite")
plt.ylabel("Log Omega")
plt.xlabel("U1")
plt.legend()

plt.subplot(1,2,2)
lomegamax=np.max(composite)
plt.plot(q1,np.exp((lomega1+lomega2)-lomegamax),color='green',label="Composite")
plt.ylim([0,1])
plt.ylabel("Relative contribution")
plt.xlabel("U1")
plt.legend()
plt.title("N1 = N2 = 100, q = 50")

plt.savefig("./Images/2state-100.png")

plt.figure()
N1 = 100000
N2 = 100000
qtot = 50000
q1=np.linspace(0,qtot,qtot+1)
q2 = qtot - q1

lomega1 = LOmega(N1,q1)
lomega2 = LOmega(N2,q2)

plt.subplot(1,2,1)
plt.plot(q1,lomega1,label="System 1")
plt.plot(q1,lomega2,label="System 2")
composite=lomega1+lomega2
plt.plot(q1,composite,label="Composite")
plt.xlabel("U1")
plt.ylabel("Log Omega")
plt.legend()

plt.subplot(1,2,2)
lomegamax=np.max(composite)
plt.plot(q1,np.exp((lomega1+lomega2)-lomegamax),color='green',label="Composite")
plt.ylim([0,1])
plt.xlabel("U1")
plt.ylabel("Relative contribution")
plt.legend()
plt.title("N1 = N2 = 100000, q = 50000")

plt.savefig("./Images/2state-100000.png")

#+END_SRC

#+RESULTS:

#+CAPTION: Energy distibutions in two interacting collections of two-state systems.
[[./Images/2state-100.png]]
[[./Images/2state-100000.png]]
#+RESULTS:

# #+BEGIN_EXPORT latex
# \begin{table}
#    \caption{Left: Energy distribution in two small, interacting two-state systems.  Right: Energy distribution in two large interacting two-state systems}
# \begin{tabular}{cc}
# \includegraphics[scale=0.5]{Images/2state-100.png} & \includegraphics[scale=0.5]{Images/2state-100000.png}
# \end{tabular}
# \end{table}
# #+END_EXPORT

*** Consequences of energy flow between two large systems
1. Each subsystem has energy $U_i$ and degeneracy $\Omega_i(U_i)$
2. Bring in thermal contact, $U=U_1+U_2$, $\Omega=\sum_{U_1}\Omega_1(U_1)\Omega_2(U-U_1)$
3. If systems are very large, one combination of $U_1$, $U_2$ will dominate \Omega sum. Find largest term.
        \begin{displaymath}
           \left ( \frac{\partial \Omega}{\partial U_1} \right )_{N} = 0
        \end{displaymath}
        \begin{displaymath}
 \left ( \frac{\partial \ln \Omega_1}{\partial U_1} \right )_N = \left ( \frac{\partial \ln \Omega_2}{\partial U_2} \right )_N
        \end{displaymath}
        \begin{displaymath}
 \left ( \frac{\partial S_1}{\partial U_1} \right )_N = \left ( \frac{\partial S_2}{\partial U_2} \right )_N
        \end{displaymath}
5. Thermal equilibrium is determined by equal *temperature*!
        \begin{displaymath}
            \frac{1}{T}=\left ( \frac{\partial S}{\partial U} \right )_N
          \end{displaymath}
6. Equal temperatures \rightarrow most probable distribution of energy between subsystems. 
7. (Same arguments lead to requirement that equal pressures ($P_i$) and equal chemical potentials ($\mu_i$) maximize entropy when volumes or particles are exchanged)

*** Two-state model in limit of large $N$
1. Large $N$ and Stirling's approximation
2. Fundamental thermodynamic equation of two-state system:
        \begin{displaymath}
          S(U)=k_B\ln \Omega(N,q) = \ldots = -k_B \left ( x \ln x + (1-x) \ln (1-x) \right ), \mathrm{where}\
          x = q/N = U/N\epsilon
        \end{displaymath}
3. Temperature is derivative of entropy wrt energy, yields
          \begin{displaymath}
            \left( \frac{\partial S}{\partial U} \right )_N = T \rightarrow U(T) = \frac{N\epsilon e^{-\epsilon/k_BT}}{1+e^{-\epsilon/k_BT}}
          \end{displaymath}
4. $T \rightarrow 0, U \rightarrow 0, S \rightarrow 0$, minimum degeneracy, only 1 possible state
5. $T \rightarrow \infty, U \rightarrow N\epsilon/2, S \rightarrow k_B \ln 2$, maximum degeneracy, $_N C_{N/2} = 2^N$ possible states
6. Differentiate again to get heat capacity
          \begin{displaymath}
            C_N = \left ( \frac{\partial U}{\partial T} \right )_N = \frac{(\epsilon/k_B T)^2 e^{-\epsilon/k_BT}}{(1+e^{-\epsilon/k_B T})^2}
          \end{displaymath}

*** Example of microcanonical ("$NVE$") ensemble
1. Direct evaluation of $S(U)$ is generally intractable, so seek simpler approach
#+BEGIN_SRC python :exports results :results output
import numpy as np
import matplotlib.pyplot as plt

k = 8.61734e-5   # eV /K
theta = 300.  # epsilon/kB


def q(T):
   return 1. + np.exp(-theta/T)

def P1(T):
   return 1/q(T)

def P2(T):
   return np.exp(-theta/T)/q(T)

def A(T):
   return -k*T*np.log(q(T))

def U(T):
   epsilon = theta*k
   return epsilon * np.exp(-theta/T) / q(T)

def C(T):
   return (theta/T)**2 * np.exp(-theta/T)/(q(T)*q(T))

def S(T):
   return (U(T) - A(T))/T

T = np.linspace(1,2001,500)

plt.figure()
plt.plot(T,q(T))
plt.xlabel('Temperature (K)')
plt.ylabel('Partition function')
plt.title('Two-state system partition function')
plt.savefig('./Images/2state-partition.png')

plt.figure()
plt.plot(T,P1(T),label='State 1')
plt.plot(T,P2(T),label='State 2')
plt.xlabel('Temperature (K)')
plt.ylabel('Probability')
plt.legend()
plt.title('Two-state system probabilities')
plt.savefig('./Images/2state-probability.png')

plt.figure()
plt.plot(T,A(T))
plt.xlabel('Temperature (K)')
plt.ylabel('Free energy (eV/particle)')
plt.title('Two-state system Helmholtz free energy')
plt.savefig('./Images/2state-helmholtz.png')

plt.figure()
plt.plot(T,U(T))
plt.xlabel('Temperature (K)')
plt.ylabel('Internal energy (eV/particle)')
plt.title('Two-state system internal energy')
plt.savefig('./Images/2state-internal.png')

plt.figure()
plt.plot(T,C(T))
plt.xlabel('Temperature (K)')
plt.ylabel('Heat capacity (eV/T)')
plt.title('Two-state system heat capacity')
plt.savefig('./Images/2state-heatcapacity.png')

plt.figure()
plt.plot(T,S(T))
plt.xlabel('Temperature (K)')
plt.ylabel('Entropy (eV/T)')
plt.title('Two-state system entropy')
plt.savefig('./Images/2state-entropy.png')


#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_COMMENT
[[./Images/2state-partition.png]]
[[./Images/2state-probability.png]]
[[./Images/2state-helmholtz.png]]
[[./Images/2state-internal.png]]
[[./Images/2state-heatcapacity.png]]
[[./Images/2state-entropy.png]]
#+END_COMMENT

#+BEGIN_EXPORT latex
\begin{table}
   \caption{Two-state system thermodynamics}
\begin{tabular}{cc}
\includegraphics[scale=0.5]{Images/2state-partition.png} & \includegraphics[scale=0.5]{Images/2state-probability.png} \\
\includegraphics[scale=0.5]{Images/2state-helmholtz.png} & \includegraphics[scale=0.5]{Images/2state-internal.png} \\
\includegraphics[scale=0.5]{Images/2state-heatcapacity.png} & \includegraphics[scale=0.5]{Images/2state-entropy.png}
\end{tabular}
\end{table}
#+END_EXPORT
** Lecture 18: Canonical ($NVT$) ensemble
*** Partition function
1. Imagine a system brought into thermal equilibrium with a much larger "reservoir" of constant $T$, such that the aggregate has a total energy $U$
2. Degeneracy of a given system microstate $j$ with energy $U_j$ is $\Omega_{res}(U-U_j)$
        \begin{eqnarray*}
          T = \frac{dU_{res}}{k_Bd\ln\Omega_{res}} \\
          \Omega_{res}(U-U_j) \propto e^{-U_j/k_B T}
        \end{eqnarray*}
3. Probability for system to be in a microstate with energy $U_j$ given by Boltzmann distribution!
        \begin{displaymath}
          P(U_j) \propto e^{-U_j/k_B T} = e^{-U_j \beta}
        \end{displaymath}
4. Partition function "normalizes" distribution, $Q(T,V) = \sum_j e^{-U_j \beta}$
5. Partition function counts the number of states accessible to a system at a given $V$ and in equilibrium with a reservoir at $T$
*** Energy factoring (sidebar)
1. If system is large, how to determine it's energy states $U_j$?  There would be many, many of them!
2. One simplification is if we can write energy as sum of energies of individual elements (atoms, molecules, degrees of freedom) of system:
    \begin{align}
      U_j&=\epsilon_j(1)+\epsilon_j(2) + ... + \epsilon_j(N) \\
      Q(N,V,T) &= \sum_j e^{-U_j\beta} \\
      &=\sum_je^{-(\epsilon_j(1)+\epsilon_j(2) + ... + \epsilon_j(N))\beta}
    \end{align}
3. /If/ molecules/elements of system can be distinguished from each
        other (like atoms in a fixed lattice), expression can be factored:
      \begin{align}
        Q(N,V,T)&=\left ( \sum_j e^{-\epsilon_j(1)\beta}\right )\cdots \left ( \sum_j
          e^{-\epsilon_j(N)\beta}\right ) \\
      &= q(1)\cdots q(N) \\
      \text{Assuming all the elements are the same:}\\
      &= q^N \\
     q&=\sum_j e^{-\epsilon_j \beta}: \mathrm{molecular\ partition\ function}
   \end{align}
4. /If not/ distinguishable (like molecules in a liquid or gas, or electrons in a solid), problem is difficult, because identical
      arrangements of energy amongst elements should only be counted once.
5. Approximate solution, good almost all the time:
    \begin{equation}
      Q(N,V,T)=q^N/N!
    \end{equation}
6. Sidebar: "Correct" factoring depends on whether individual elements are fermions or bosons, leads to funny things like superconductivity and superfluidity.

*** Distinguishable vs. indistinguishable particles
1. $q(V,T)$ counts states available to a single element of a system, like a molecule in a gas or in a solid
2. Distinguishable (e.g., in a solid): $Q(N,V,T) = q(V,T)^N$
3. Indistinguishable (e.g., a gas): $Q(N,V,T)\approx q(V,T)^N/N!$

*** Two-state system again
1. Partition function, $q(T)=1+e^{-\epsilon\beta}$
2. State probabilities
3. Internal energy $U(T)$
        \begin{equation}
          U(T)=-N \left ( \frac{\partial \ln(1+e^{-\epsilon\beta})}{\partial\beta}
          \right)=\frac{N\epsilon e^{-\epsilon\beta}}{1+e^{-\epsilon\beta}}
        \end{equation}
4. Heat capacity $C_v$
   1. Minimum when change in states with $T$ is small
   2. Maximize when chagne in states with $T$ is large
5. Helmholtz energy, $A= -\ln q/\beta$, decreasing function of $T$
6. Entropy


*** Thermodynamic functions in canonical ensemble

#+BEGIN_EXPORT latex
\begin{table}\small
  \begin{center}
    \caption{Equations of the Canoncial ($NVT$) Ensemble}
    \label{Canonical}
    \begin{tabular}[H]{lccc}
      \hline
$\beta=1/k_BT$ & {\bf Full Ensemble} & {\bf Distinguishable particles} & {\bf Indistinguishable
particles} \\
               &               & (e.g. atoms in a lattice) & (e.g. molecules in
               a fluid) \\
\hline
Single particle & & & \\partition function& & $\displaystyle q(V,T) = \sum_i
e^{-\epsilon_i\beta} $& $\displaystyle q(V,T) = \sum_i e^{-\epsilon_i\beta} $ \\
Full partition & & & \\function & $\displaystyle Q(N,V,T) = \sum_j e^{-U_j\beta} $ &
$\displaystyle Q = q(V,T)^N $ & $\displaystyle Q = q(V,T)^N/N! $ \\
Log partition &  $\ln Q$ & $N\ln q$ & $ N\ln q - \ln N! $\\
function & & & $\approx N(\ln q - \ln N +1)$ \\ & & & \\
Helmholtz energy & $\displaystyle -\frac{\ln Q}{\beta}$ & $\displaystyle
-\frac{N\ln q}{\beta}$ & $\displaystyle -\frac{N}{\beta}\left (\ln\frac{q}{N} +
  1 \right ) $ \\
($A=U-TS$) & & & \\ & & &  \\
Internal energy ($U$)& $\displaystyle -\left (\frac{\partial\ln
    Q}{\partial\beta}\right )_{NV}$ & $\displaystyle -N\left (\frac{\partial\ln
    q}{\partial\beta}\right )_{V}$ &  $\displaystyle -N\left (\frac{\partial\ln
    q}{\partial\beta}\right )_{V}$ \\ & & & \\
Pressure ($P$) & $\displaystyle  \frac{1}{\beta}\left (\frac{\partial\ln
    Q}{\partial V}\right )_{N\beta}$ & $\displaystyle \frac{N}{\beta}\left (\frac{\partial\ln
    q}{\partial V}\right )_{\beta}$ &  $\displaystyle \frac{N}{\beta}\left (\frac{\partial\ln
    q}{\partial V}\right )_{\beta}$ \\ & & & \\

Entropy ($S/k_B$) & $ \beta U + \ln Q$ & $\beta U + N \ln q$ & $\beta U +
N\left ( \ln(q/N) + 1\right )$ \\ & & & \\
Chemical potential ($\mu$) & $\displaystyle -\frac{1}{\beta}\left ( \frac{\partial \ln
    Q}{\partial N}\right )_{VT} $& $\displaystyle -\frac{\ln q}{\beta}$ & $\displaystyle
-\frac{\ln (q/N)}{\beta}$ \\ & & & \\
\hline
    \end{tabular}
{\bf NOTE!} All energies are referenced to their values at 0~K.  Enthalpy $H=U+PV$, Gibb's
Energy $G=A+PV$.
  \end{center}
\end{table}
#+END_EXPORT

** Lecture 19: Molecular Partition Functions
*** Ideal gas of molecules
      \begin{displaymath}
        Q_{ig}(N,V,T) = \frac{(q_\mathrm{trans}q_\mathrm{rot}q_\mathrm{vib})^N}{N!}
      \end{displaymath}

*** Particle-in-a-box (translational states of a gas)
1. Energy states $\epsilon_n=n^2\epsilon_0, n=1,2, \ldots$, $\epsilon_0$ tiny for macroscopic $V$
2. $\Theta_\mathrm{trans} = \epsilon_0/k_B$ translational temperature
3. $\Theta_\mathrm{trans} << T \rightarrow$ many states contribute to $q_\mathrm{trans}\rightarrow$ integral approximation
            \begin{eqnarray*}
              q_\mathrm{trans,1D} \approx \int_0^\infty e^{-x^2\beta\epsilon_0}dx =
              L/\Lambda \\
              \Lambda = \left ( \frac{h^2\beta}{2\pi m} \right )^{1/2}\
              \mathrm{thermal\ wavelength} \\
              q_\mathrm{trans,3D} = V/\Lambda^3
            \end{eqnarray*}
4. Internal energy
5. Heat capacity
6. Equation of state (!)
7. Entropy: Sackur-Tetrode equation

*** Rigid rotor (rotational states of a gas)
1. sum over rigid energy states and degeneracies of rigid rotor
2. $\Theta_\mathrm{rot} = \hbar^2/2 I k_B$
3. "High" T $q_\mathrm{rot}(T) \approx \sigma \Theta_\mathrm{rot}/T$, most often true
*** Harmonic oscillator (vibrational states of a gas)
1. sum over harmonic oscillator energy states
2. $\Theta_\mathrm{vib}=h\nu/k_B$, typically 100's to 1000's K
3. introduce strong non-linear $T$ dependence to thermodynamic properties

*** Electronic partition functions $\rightarrow$ spin multiplicity
*** Many-particle molecule
1. partition function is a product of all degrees of freedom
   \begin{displaymath}
   q(T,V) = q_\text{trans} \left ( \prod_{i=1}^3 q_\text{rot}^{(i)}\right ) \left (  \prod_{i = 1}^{3N-6} q_\text{vib}^{(i)}\right ) q_\text{elec}
    \end{displaymath}
2. thermodynamic quantities are sums of all degrees of freedom
*** Non-ideality
1. Real molecules interact through vdW interactions
2. Particle-in-a-box model is a start, have to elaborate to get at properties of liquids, solutions, ....
3. See Hill, /J. Chem. Ed./ *1948*, /25/, p. 347 [[http://dx.doi.org/10.1021/ed025p347]]

#+BEGIN_EXPORT latex
\begin{table}
\begin{center}
    \caption{\large{Statistical Thermodynamics of an Ideal Gas}}
   \begin{description}
    \item[\underline{Translational DOFs}] {3-D particle in a box model}

$\displaystyle \theta_\mathrm{trans}= \frac{\pi^2\hbar^2}{2 m
  L^2 k_B}$,
$\displaystyle \Lambda=h\left( \frac{\beta}{2\pi m}\right )^{1/2}$

For $ T >> \Theta_\mathrm{trans}$, $\Lambda << L$, $\displaystyle
q_\mathrm{trans}=V/\Lambda^3$ (essentially always true)

\begin{tabular}{ccc}
$\displaystyle U_\mathrm{trans}=\frac{3}{2}RT$ & $\displaystyle C_\mathrm{v,trans} =
\frac{3}{2}R $ & $\displaystyle S^\circ_\mathrm{trans}=R \ln \left (
  \frac{e^{5/2}V^\circ}{N^\circ \Lambda^3}\right ) = R \ln \left (
  \frac{e^{5/2}k_BT}{P^\circ \Lambda^3}\right ) $ \\
\end{tabular}

  \item[\underline{Rotational DOFs}] {Rigid rotor model}
\begin{description}
\item[Linear molecule]{}
$\theta_\mathrm{rot} =hcB/k_B$

\begin{equation*}
q_\mathrm{rot}=\frac{1}{\sigma}\sum_{l=0}^\infty (2l+1)e^{-l(l+1)\theta_\mathrm{rot}/T},
\approx \frac{1}{\sigma}\frac{T}{\theta_\mathrm{rot}},\ \ T>>\theta_\mathrm{rot}\ \ \ \sigma = \left \{
        \begin{array}{rl}
          1, & \text{unsymmetric} \\
          2, & \text{symmetric}
        \end{array} \right .
\end{equation*}
\begin{tabular}{ccc}
$\displaystyle U_\mathrm{rot}=RT$ & $\displaystyle C_\mathrm{v,rot} =
R $ & $\displaystyle S^\circ_\mathrm{rot}=R (1-\ln(\sigma\theta_\mathrm{rot}/T)) $ \\
\end{tabular}


\item[Non-linear molecule]{} $\theta_{\mathrm{rot},\alpha}=hcB_\alpha/k_B$
\begin{equation*}
q_\mathrm{rot} 
\approx \frac{1}{\sigma}\left ( \frac{\pi
    T^3}{\theta_{\mathrm{rot},\alpha}\theta_{\mathrm{rot},\beta}\theta_{\mathrm{rot},\gamma}}
  \right )^{1/2},\ \ T>>\theta_{\mathrm{rot},\alpha,\beta,\gamma}\ \ \ \sigma =
  \text{rotational symmetry number}
\end{equation*}
\begin{tabular}{ccc}
$\displaystyle U_\mathrm{rot}=\frac{3}{2}RT$ & $\displaystyle C_\mathrm{v,rot} = \frac{3}{2}
R $ & $\displaystyle S^\circ_\mathrm{rot}=\frac{R}{2}
\left ( 3-\ln\frac{\sigma\theta_{\mathrm{rot},\alpha}\theta_{\mathrm{rot},\beta}\theta_{\mathrm{rot},\gamma}}{\pi
  T^3} \right ) $ \\
\end{tabular}

\end{description}

\item[\underline{Vibrational DOFs}] {Harmonic oscillator model}
\begin{description}
\item[Single harmonic mode] {$\theta_\mathrm{vib}=h\nu/k_B $}
  \begin{equation*}
    q_\mathrm{vib}=\frac{1}{1-e^{-\theta_\mathrm{vib}/T}} \approx
      \frac{T}{\theta_\mathrm{vib}}, \ \ \ T>>\theta_\mathrm{vib}
  \end{equation*}

\begin{tabular}{ccc}
$ U_\mathrm{vib}= $ & $  C_\mathrm{v,vib} = $ & $S^\circ_{\mathrm{vib},i}=$ \\
$\displaystyle
R\frac{\theta_\mathrm{vib}}{e^{\theta_\mathrm{vib}/T}-1}$ &
$\displaystyle R\left (
  \frac{\theta_\mathrm{vib}}{T}\frac{e^{\theta_\mathrm{vib}/2T}}{e^{\theta_\mathrm{vib}/T}-1}
\right )^2 $ & $\displaystyle R \left ( \frac{\theta_\mathrm{vib}/T}{e^{\theta_\mathrm{vib}/T}-1}
-\ln(1-e^{-\theta_\mathrm{vib}/T})\right ) $ \\
\end{tabular}

\item[Multiple harmonic modes] {$\theta_{\mathrm{vib},i}=h\nu_i/k_B $}

  \begin{equation*}
    q_\mathrm{vib}=\prod_i\frac{1}{1-e^{-\theta_{\mathrm{vib},i}/T}} 
  \end{equation*}

\begin{tabular}{ccc}
$ U_\mathrm{vib}= $ & $  C_\mathrm{v,vib} = $ & $S^\circ_{\mathrm{vib},i}=$ \\
$\displaystyle
R\sum_i\frac{\theta_{\mathrm{vib},i}}{e^{\theta_{\mathrm{vib},i}/T}-1}$ &
$\displaystyle R \sum_i \left (
  \frac{\theta_{\mathrm{vib},i}}{T}\frac{e^{\theta_{\mathrm{vib},i}/2T}}{e^{\theta_{\mathrm{vib},i}/T}-1}
\right )^2 $ & $\displaystyle R \left ( \frac{\theta_{\mathrm{vib},i}/T}{e^{\theta_{\mathrm{vib},i}/T}-1}
-\ln(1-e^{-\theta_{\mathrm{vib},i}/T})\right ) $ \\
\end{tabular}

\end{description}
\item[\underline{Electronic DOFs}] {}
$q_\mathrm{elec} = \text{spin multiplicity}$


\end{description}
\end{center}
\end{table}
#+END_EXPORT

#+CAPTION: Contributions to ideal gas thermodynamics
|---------------+------------------------------------+------------------+-------------+-----------------|
|               | Characteristic                     | Characteristic   | States @ RT |                 |
|               | Energy (cm^{-1})                   | Temperature (K)  |             |                 |
|---------------+------------------------------------+------------------+-------------+-----------------|
| translational | $\hbar^2/2 m L^2 \approx 10^{-21}$ | $10^{-21}$       | $10^{30}$   | classical limit |
|               |                                    |                  |             |                 |
| rotational    | $\approx 1$                        | $\approx 1$      | 100's       | semi-classical  |
|               |                                    |                  |             |                 |
| vibrational   | $\approx 1000$                     | $\approx 1000$   | 1           | non-classical   |
|               |                                    |                  |             |                 |
| electronic    | $\approx 10,000$                   | $\approx 10,000$ | 1           | non-classical   |
|---------------+------------------------------------+------------------+-------------+-----------------|

#+BEGIN_SRC python :exports results :results output
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import fsolve

k = 8.61733e-5      # eV /K
h = 4.13566766e-15  # eV s
eVtokJ = 96.485332
autoeV= 27.212      # eV
Nav = 6.022e23      # Avogadro's number 
amutoeVc2 = 931494095.17 # convert amu to eV/c^2
R0 = k * eVtokJ * 1000.       # gas constant in J/mol K
c = 299792458 # m / s

class Molecule(object):
    def __init__(self, name, mass, energy, rot, vib, helmholtz):
        self.name = name
        self.mass = mass
        self.energy = energy
        self.rot = rot
        self.vib = vib
        self.helmholtz = helmholtz

    def Hello(self):
        return "Hello {}".format(self.name)

    def Lambda(self, T):
        m = self.mass * amutoeVc2
        return h/np.sqrt(2*np.pi*m*k*T)*c

    def qtrans(self,T):  #  mole/m^3
        m = self.mass * amutoeVc2
        l = h/np.sqrt(2*np.pi*m*k*T)*c
        return (1./Nav)*(1./l)**3

    def qrot(self,T):
        if self.rot[1] > 0:
            return np.sqrt((np.pi*(T/self.rot[0])*(T/self.rot[1])*(T/self.rot[2])))
        else:
            return T/self.rot[0]

    def qvib(self,T):
        Qvib = 1
        for mode in self.vib:
            qvib = qvib*(1.-np.exp(-mode/T))**-1
        return qvib

    def ZPE(self):
        ZPE=0.
        for mode in self.vib:
            ZPE = ZPE + mode
        return ZPE * (0.5)*k

    def Utrans(self,T):
        return 1.5*k*T

    def Urot(self,T):
        return 1.5*k*T

    def Uvib(self,T):
        Uvib=0.
        for mode in self.vib:
            Uvib=Uvib+k*(mode/(np.exp(mode/T)-1.0))
        return Uvib

# Fundamental relationships
def A(q):
   return -k*T*np.log(q)

def S(A,U,T):
   return (U - A)/T

def Delta(nu,A):
    return np.dot(nu,A)

Ethane = Molecule("Ethane", 30.04695, -79.8304174812, [3.84821, 0.95472, 0.95472], [450.15,  1196.99,  1196.99,  1453.24,  1777.11, 1777.12,  2060.75,  2091.81,  2204.14,  2204.14, 2212.26,  2212.26,  4385.10,  4386.31,  4459.07, 4459.07,  4494.15,  4494.15],[])

Ethylene = Molecule("Ethylene", 28.0313, -78.5874582996, [7.05282, 1.44180, 1.19708], [1201.68,  1375.63,  1403.93,  1539.30,  1795.67, 2008.40,  2150.27,  2475.38,  4535.29,  4557.52, 4636.49,  4673.24], [])

VA = Molecule("Vinyl alcohol", 44., -153.802227784, [3.06869, 0.49808, 0.42852],[342.12,   692.39,  1032.15,  1198.36,  1386.62, 1411.99,  1670.11,  1880.98,  1967.27,  2101.01, 2532.91,  4541.20,  4591.62,  4716.63,  5454.14],[])

Ac = Molecule("Acetaldehyde", 44., -153.830119460, [2.72923, 0.48351, 0.43371], [222.94,  729.92,  1121.87,  1285.63,  1636.17, 1646.79,  2018.97,  2080.76, 2143.85,  2157.44,  2651.18,  4169.12,  4379.22,  4459.71,  4553.14],[])

Hydrogen = Molecule("Hydrogen", 2.01565, -1.17548235778, [87.18829, 0., 0.], [6402.62], [])

T = np.linspace(500,1500,500)

#
# Ethane thermochemistry
# 

plt.figure()
plt.plot(T,np.log(Ethane.qtrans(T)),label="trans")
plt.plot(T,np.log(Ethane.qrot(T)),label="rot")
plt.plot(T,np.log(Ethane.qvib(T)),label="vib")
plt.xlabel('Temperature (K)')
plt.ylabel('ln q')
plt.title('Partition functions vs temperature (1 mol/m3)')
plt.legend()
plt.savefig('./Images/ethane-partition.png')

AtransEthane = A(Ethane.qtrans(T))
ArotEthane = A(Ethane.qrot(T))
AvibEthane = A(Ethane.qvib(T))

plt.figure()
plt.plot(T,AtransEthane*eVtokJ,label="trans")
plt.plot(T,ArotEthane*eVtokJ,label="rot")
plt.plot(T,AvibEthane*eVtokJ,label="vib")
plt.xlabel('Temperature (K)')
plt.ylabel('Helmholtz (kJ/mol)')
plt.title('Helmholtz contributions vs temperature (1 mol/m3)')
plt.legend()
plt.savefig('./Images/ethane-helmholtz.png')

UtransEthane = Ethane.Utrans(T)
UrotEthane = Ethane.Urot(T)
UvibEthane = Ethane.Uvib(T)

plt.figure()
plt.plot(T,UtransEthane*eVtokJ,label="trans")
plt.plot(T,UrotEthane*eVtokJ,label="rot")
plt.plot(T,UvibEthane*eVtokJ,label="vib")
plt.xlabel('Temperature (K)')
plt.ylabel('Internal Energy (kJ/mol)')
plt.title('Internal energy contributions vs temperature')
plt.legend()
plt.savefig('./Images/ethane-energy.png')

StransEthane=S(AtransEthane,UtransEthane,T)
SrotEthane=S(ArotEthane,UrotEthane,T)
SvibEthane=S(AvibEthane,UvibEthane,T)

plt.figure()
plt.plot(T,StransEthane*eVtokJ*1000.,label="trans")
plt.plot(T,SrotEthane*eVtokJ*1000.,label="rot")
plt.plot(T,SvibEthane*eVtokJ*1000.,label="vib")
plt.xlabel('Temperature (K)')
plt.ylabel('Entropy (J/mol K)')
plt.title('Entropy contributions vs temperature (1 mol/m3)')
plt.legend()
plt.savefig('./Images/ethane-entropy.png')

#+END_SRC

#+RESULTS:

#+BEGIN_EXPORT latex
\begin{table}
   \caption{Ethane thermodynamics}
\begin{tabular}{cc}
\includegraphics[scale=0.5]{./Images/ethane-partition.png} & \includegraphics[scale=0.5]{./Images/ethane-helmholtz.png} \\
\includegraphics[scale=0.5]{./Images/ethane-energy.png} & 
\includegraphics[scale=0.5]{./Images/ethane-entropy.png}
\end{tabular}
\end{table}
#+END_EXPORT

** Lecture 20: Chemical reactions and equilibria
*** Isothermal, isbaric separation for ideal gas mixture
    \[ \text{A/B} (N_{A},N_{B},V,T) \rightarrow \text{A}(N_{A},x_{A}V,T) + \text{B}(N_{B},x_{B},V,T) \]
1. Apply ideal gas expressions to all parts and compute a difference!
2. Internal energy, $\Delta U(T) = 0$ 
3. Entropy, $\Delta S(T)/(N_A+N_B) = k_B(x_A\ln(x_A) + x_B \ln(x_B))$
4. Minimum work of separation, $\Delta A(T) = \Delta U - T\Delta S > 0$
5. Entropy favors mixing
*** Chemical reaction thermodynamics
1. Transformation that conserves atoms
2. Example: vinyl alcohol to acetaldehyde, \ce{H2C=CH(OH) -> CH3CH(O)}
3. Differences between *well defined* initial and final states
  \[ \ce{H2C=CH(OH)} (\SI{1}{mol},\SI{1}{bar},\SI{298}{K}) \ce{-> CH3CH(O)} (\SI{1}{mol},\SI{1}{bar},\SI{298}{K})  \]
4. Reaction entropy captures contributions of all degrees of freedom
     \[\Delta S^\circ(T) = \Delta S^\circ_\text{trans}(T)+ \Delta S_\text{rot}(T) +\Delta S_\text{vib}(T)\]
5. Reaction energy (internal, Helmholtz, ...) must /also/ capture difference
   in \SI{0}{K} electronic energy
    \[\Delta U^\circ(T) = \Delta U^\circ_\text{trans}(T)+ \Delta U_\text{rot}(T) +\Delta U_\text{vib}(T) + \Delta E_\text{elec}(0) + \Delta ZPE\]
6. "Standard state"
   1. derives from concentration dependence of entropy
   2. corresponds to some standard choice, $(N/V)^\circ = c^\circ$, e.g. \SI{1}{mol/l} (T-independent), or $(N/V)^\circ = P^\circ/RT$, e.g. \SI{1}{bar} (T-dependent)
7. Permits functions to be easily computed at other concentrations, e.g.
     \begin{displaymath}
     A(T,N/V)  = A^\circ(T) + k T \ln\left ( (N/V)/(N/V)^\circ \right ) =A^\circ(T) + k T \ln \left ( c/c^\circ \right ) \
     G(T,P)  = G^\circ(T) + k T \ln\left ( P/P^\circ \right )
     \end{displaymath}
*** Chemical equilibrium
1. Reaction advancement \(\xi\) describes progress from reactants to products
   1. "ICE": \(n_i = n_{i0} -\nu_i \xi \)
2. Free energy of a /mixture/ of reactants and products
    \[G(T,\xi) = \xi  (\Delta G^\circ + k T \sum_i \nu_i \ln P_i/P^\circ) \]
3. Equilibrium condition---minimize \(G\) with respect to \(\xi\)
4. Equilibrium condition---equate chemical potentials
     \begin{eqnarray*}
    \mu_A(N,V,T) & = & \mu_B(N,V,T) \\
    E_A(0) - k T \ln (q_A/N_A) & = & E_B(0) - k T \ln (q_B/N_B) \\
   \frac{N_B}{N_A} =  \frac{N_B/V}{N_A/V} & = &\frac{q_B(T,V)/V}{q_A(T,V)/V} e^{-\Delta U(0)/kT}
     \end{eqnarray*}
5. \(q/V = 1/\Lambda^3\) has units of number/volume, or concentration
6. Equilibrium constant---convert units to some standard concentration \(c^\circ\) or pressure \(P^\circ\)
    \begin{eqnarray*}
     q_A^\circ(T) & = & (q_A(T,V)/V) (1/c^\circ) \\
     q_A^\circ(T) & = & (q_A(T,V)/V)(k_B T/P^\circ) \\ 
   K_{eq}(T) & = &\frac{q_B^\circ(T)}{q_A^\circ(T)} e^{-\Delta U(0)/kT} = e^{-\Delta G^\circ(T)/kT} 
    \end{eqnarray*}
7. ICE/equilibrium calculation for \ce{H2C=CH(OH) -> CH3CH(O)}
8. Free energy convolutes energy and entropy effects
   1. \(\Delta H\), \(\Delta S\) weakly \(T\)-dependent
   2. \(\Delta G = \Delta H - T\Delta S\) can be strongly \(T\)-dependent
9. Gibbs-Helmholtz relation
 \[ \left ( \frac{\partial G/T}{\partial T}\right )= -\frac{H}{T^2}\]
 \[ \left ( \frac{\partial \Delta G^\circ/T}{\partial T}\right )= -\frac{\Delta H^\circ}{T^2}\]
 \[ \left ( \frac{\partial \ln K(T)}{\partial 1/T}\right )= -\frac{\Delta H^\circ}{R}\]
10. van't Hoff relationship, when $T$ dependence of \(\Delta H\) is small
  \[  \ln\left ( \frac{K(T_2)}{K(T_1)}\right )= -\frac{\Delta H^\circ}{R}\left ( \frac{1}{T_2}-\frac{1}{T_1}\right ) \]
11. ICE/equilibrium calculation for ethane dehydrogenation, \ce{C2H6 -> C2H4 + H2}, 1 bar standard state

#+BEGIN_SRC python :exports results :results output
# snippet to solve VA to AC equilibrium

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import fsolve

def equil1(y):      # 1 bar
    return y - K*(1-y)

K = 120
y0 = 0.99999

xeq = fsolve(equil1,y0)

# print(xeq)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :exports results :results output
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import fsolve

#
# In this code, qtrans is reported in mol/volume so that standard state is also in per mole.  Might be clearer to
# report qtrans as a number/volume to be consistent with homework.
#


k = 8.61733e-5      # eV /K
h = 4.13566766e-15  # eV s
eVtokJ = 96.485332
autoeV= 27.212      # eV
Nav = 6.022e23      # Avogadro's number 
amutoeVc2 = 931494095.17 # convert amu to eV/c^2
R0 = k * eVtokJ * 1000.       # gas constant in J/mol K
c = 299792458 # m / s

class Molecule(object):
    def __init__(self, name, mass, energy, rot, vib, helmholtz):
        self.name = name
        self.mass = mass
        self.energy = energy
        self.rot = rot
        self.vib = vib
        self.helmholtz = helmholtz

    def Hello(self):
        return "Hello {}".format(self.name)

    def Lambda(self, T):
        m = self.mass * amutoeVc2
        return h/np.sqrt(2*np.pi*m*k*T)*c

    def qtrans(self,T):  #  mole/m^3
        m = self.mass * amutoeVc2
        l = h/np.sqrt(2*np.pi*m*k*T)*c
        return (1./Nav)*(1./l)**3

    def qrot(self,T):
        if self.rot[1] > 0:
            return np.sqrt((np.pi*(T/self.rot[0])*(T/self.rot[1])*(T/self.rot[2])))
        else:
            return T/self.rot[0]

    def qvib(self,T):
        qvib = 1
        for mode in self.vib:
            qvib = qvib*(1.-np.exp(-mode/T))**-1
        return qvib

    def ZPE(self):
        ZPE=0.
        for mode in self.vib:
            ZPE = ZPE + mode
        return ZPE * (0.5)*k

    def Utrans(self,T):
        return 1.5*k*T

    def Urot(self,T):
        return 1.5*k*T

    def Uvib(self,T):
        Uvib=0.
        for mode in self.vib:
            Uvib=Uvib+k*(mode/(np.exp(mode/T)-1.0))
        return Uvib

# Fundamental relationships
def A(q):
   return -k*T*np.log(q) - k*T

def S(A,U,T):
   return (U - A)/T

def Delta(nu,A):
    return np.dot(nu,A)

Ethane = Molecule("Ethane", 30.04695, -79.8304174812, [3.84821, 0.95472, 0.95472], [450.15,  1196.99,  1196.99,  1453.24,  1777.11, 1777.12,  2060.75,  2091.81,  2204.14,  2204.14, 2212.26,  2212.26,  4385.10,  4386.31,  4459.07, 4459.07,  4494.15,  4494.15],[])

Ethylene = Molecule("Ethylene", 28.0313, -78.5874582996, [7.05282, 1.44180, 1.19708], [1201.68,  1375.63,  1403.93,  1539.30,  1795.67, 2008.40,  2150.27,  2475.38,  4535.29,  4557.52, 4636.49,  4673.24], [])

VA = Molecule("Vinyl alcohol", 44., -153.802227784, [3.06869, 0.49808, 0.42852],[342.12,   692.39,  1032.15,  1198.36,  1386.62, 1411.99,  1670.11,  1880.98,  1967.27,  2101.01, 2532.91,  4541.20,  4591.62,  4716.63,  5454.14],[])

Ac = Molecule("Acetaldehyde", 44., -153.830119460, [2.72923, 0.48351, 0.43371], [222.94,  729.92,  1121.87,  1285.63,  1636.17, 1646.79,  2018.97,  2080.76, 2143.85,  2157.44,  2651.18,  4169.12,  4379.22,  4459.71,  4553.14],[])

Hydrogen = Molecule("Hydrogen", 2.01565, -1.17548235778, [87.18829, 0., 0.], [6402.62], [])

T = np.linspace(500,1500,500)

#
# Ethane dehydrogenation at 1 bar
#
stdconc = (1e5/(R0*T)) # (1 bar/ R T) = mol/m3

nu = np.array([-1,1,1])

dUtrans = Delta(nu,np.array([Ethane.Utrans(T),Ethylene.Utrans(T),Hydrogen.Utrans(T)]))
dUrot =   Delta(nu,np.array([Ethane.Urot(T),Ethylene.Urot(T),Hydrogen.Urot(T)]))
dUvib =   Delta(nu,np.array([Ethane.Uvib(T),Ethylene.Uvib(T),Hydrogen.Uvib(T)]))
deltaE0 = Delta(nu,np.array([Ethane.energy,Ethylene.energy,Hydrogen.energy]))*autoeV
deltaZPE = Delta(nu,np.array([Ethane.ZPE(),Ethylene.ZPE(),Hydrogen.ZPE()]))
deltaU = dUtrans + dUrot + dUvib + deltaE0 + deltaZPE

plt.figure()
plt.plot(T,dUtrans*eVtokJ,label="Utrans")
plt.plot(T,dUrot*eVtokJ,label="Urot")
plt.plot(T,dUvib*eVtokJ,label="Uvib")
plt.plot([500,1500],[deltaZPE*eVtokJ,deltaZPE*eVtokJ],label="ZPE")
plt.plot([500,1500],[deltaE0*eVtokJ,deltaE0*eVtokJ],label="E0")
plt.plot(T,deltaU*eVtokJ,label="Utotal")
# plt.plot(T,deltaA*eVtokJ,label="Atotal")
plt.xlabel('Temperature (K)')
plt.ylabel('Energy (kJ/mol)')
plt.title('Ethane Dehydrogenation Reaction Energy Contributions')
plt.legend()
plt.savefig('./Images/dehydro-energy.png')

Atransethane = A(Ethane.qtrans(T)) + k * T * np.log(stdconc/1.)   # 1 bar standard state
Arotethane = A(Ethane.qrot(T))
Avibethane = A(Ethane.qvib(T))
Aethane = Atransethane + Arotethane + Avibethane - k*T
Stransethane = S(Atransethane,Ethane.Utrans(T),T)
Srotethane =   S(Arotethane,Ethane.Urot(T),T)
Svibethane =   S(Avibethane,Ethane.Uvib(T),T)
Uethane = Ethane.Utrans(T) + Ethane.Urot(T) + Ethane.Uvib(T)
Sethane = S(Aethane,Uethane,T)
Gethane = Aethane + k * T 

Atransethylene = A(Ethylene.qtrans(T)) + k * T * np.log(stdconc/1.)   # 1 bar standard state
Arotethylene = A(Ethylene.qrot(T))
Avibethylene = A(Ethylene.qvib(T))
Aethylene = Atransethylene + Arotethylene + Avibethylene - k*T
Stransethylene = S(Atransethylene,Ethylene.Utrans(T),T)
Srotethylene =   S(Arotethylene,Ethylene.Urot(T),T)
Svibethylene =   S(Avibethylene,Ethylene.Uvib(T),T)
Uethylene = Ethylene.Utrans(T) + Ethylene.Urot(T) + Ethylene.Uvib(T)
Sethylene = S(Aethylene,Uethylene,T)
Gethylene = Aethylene + k * T 

Atranshydrogen = A(Hydrogen.qtrans(T)) + k * T * np.log(stdconc/1.)   # 1 bar standard state
Arothydrogen = A(Hydrogen.qrot(T))
Avibhydrogen = A(Hydrogen.qvib(T))
Ahydrogen = Atranshydrogen + Arothydrogen + Avibhydrogen - k*T
Stranshydrogen = S(Atranshydrogen,Hydrogen.Utrans(T),T)
Srothydrogen =   S(Arothydrogen,Hydrogen.Urot(T),T)
Svibhydrogen =   S(Avibhydrogen,Hydrogen.Uvib(T),T)
Uhydrogen = Hydrogen.Utrans(T) + Hydrogen.Urot(T) + Hydrogen.Uvib(T)
Shydrogen = S(Ahydrogen,Uhydrogen,T)
Ghydrogen = Ahydrogen + k * T 

dStrans = Delta(nu,np.array([Stransethane,Stransethylene,Stranshydrogen]))
dSrot   = Delta(nu,np.array([Srotethane,Srotethylene,Srothydrogen]))
dSvib = Delta(nu,np.array([Svibethane,Svibethylene,Svibhydrogen]))
deltaS = dStrans + dSrot + dSvib

plt.figure()
plt.plot(T,dStrans*eVtokJ*1000.,label="trans")
plt.plot(T,dSrot*eVtokJ*1000.,label="rot")
plt.plot(T,dSvib*eVtokJ*1000.,label="vib")
plt.plot(T,deltaS*eVtokJ*1000.,label="total")
plt.xlabel('Temperature (K)')
plt.ylabel('Entropy (J/K)')
plt.title('Ethane Dehydrogenation Reaction Entropy Contributions')
plt.legend()
plt.savefig('./Images/dehydro-entropy.png')

deltaE0 = (Ethylene.energy + Hydrogen.energy - Ethane.energy)*autoeV + (Ethylene.ZPE() + Hydrogen.ZPE() - Ethane.ZPE())
deltaU = (Uethylene + Uhydrogen - Uethane) + deltaE0
deltaS = (Sethylene + Shydrogen - Sethane)
deltaA = (Aethylene + Ahydrogen - Aethane) + deltaE0
deltaG = (Gethylene + Ghydrogen - Gethane) + deltaE0

plt.figure()
plt.plot(T,deltaU*eVtokJ,label="delta U")
plt.plot(T,T*deltaS*eVtokJ,label="T delta S")
plt.plot(T,k*T*eVtokJ,label="delta PV")
plt.plot(T,deltaG*eVtokJ,label="delta G")
plt.xlabel('Temperature (K)')
plt.ylabel('Energy (kJ/mol)')
plt.title('Ethane to Ethylene Plus Hydrogen Free Energy Contributions')
plt.legend()
plt.savefig('./Images/deyhdro.png')

xi = np.linspace(0.01,0.99,50)
yi = xi/(1.+xi)
plt.figure() 

for T0 in [800,1000,1200]:
    sc = (1e5/(R0*T0)) # (1 bar/ R T) = mol/m3

    muethane0 = Ethane.energy*autoeV + Ethane.ZPE() - k * T0 * (np.log(Ethane.qtrans(T0) + np.log(sc/1.)) + np.log(Ethane.qrot(T0)) + np.log(Ethane.qvib(T0))) 
    muethylene0 = Ethylene.energy*autoeV + Ethylene.ZPE() - k * T0 * (np.log(Ethylene.qtrans(T0) + np.log(sc/1.)) + np.log(Ethylene.qrot(T0)) + np.log(Ethylene.qvib(T0)))
    muhydrogen0 = Hydrogen.energy*autoeV + Hydrogen.ZPE() - k * T0 * (np.log(Hydrogen.qtrans(T0) + np.log(sc/1.)) + np.log(Hydrogen.qrot(T0)) + np.log(Hydrogen.qvib(T0)))

    dmu = muethylene0+muhydrogen0-muethane0
    G = xi * (dmu  + k * T0 * ((2 * np.log(yi)) - np.log(1 - yi)))

    plt.plot(xi,G*eVtokJ,label='{} K'.format(T0))


plt.xlabel('Conversion')
plt.ylabel('Free Energy (kJ/mol)')
plt.title('Ethane to Ethylene Plus Hydrogen Gibbs Energy vs Conversion')
plt.legend()
plt.savefig('./Images/dehydroG.png')


Kp = np.exp(-deltaG/(k*T))

def equil1(y):      # 1 bar
    return y * y - K*(1-y)*(1-y)

def equil100(y):    # 100 bar
    return 100*y * 100*y - K*100*(1-y)*(1-y)

old1 = 0.5
old100 = 0.5
x1 = []
x100 = []
for K in Kp: 
    xi1 = fsolve(equil1,old1)
    xi100 = fsolve(equil100,old100)
    old1 = xi1
    old100 = xi100
    x1.append(xi1)
    x100.append(xi100)

eq1=np.array(x1)
eq100 = np.array(x100)

plt.figure()
plt.plot(T,eq1/(1+eq1),label="Ethylene, Hydrogen, 1 bar")
plt.plot(T,(1.-eq1)/(1.+eq1),label="Ethane, 1 bar")
plt.plot(T,eq100/(1+eq100),label="Ethylene, Hydrogen, 100 bar")
plt.plot(T,(1.-eq100)/(1.+eq100),label="Ethane, 100 bar")
plt.title("Equilibrium mole fractions at 1 and 100 bar")
plt.xlabel('Temperature (K)')
plt.ylabel('Mole fraction')
plt.legend()

plt.savefig('./Images/equilibrium.png')
#+END_SRC

#+RESULTS:

#+BEGIN_EXPORT latex
\begin{table}
   \caption{Ethane to ethylene plus hydrogen standard state (1 bar) thermodynamcs}
\begin{tabular}{cc}
\includegraphics[scale=0.5]{./Images/dehydro-entropy.png} & \includegraphics[scale=0.5]{./Images/dehydro-energy.png} \\ \includegraphics[scale=0.5]{./Images/dehydro.png} & \includegraphics[scale=0.5]{./Images/dehydroG.png} \\
\includegraphics[scale=0.5]{./Images/equilibrium.png} 
\end{tabular}
\end{table}
#+END_EXPORT

*** Le'Chatlier's principle
1. Example: \ce{H2C=CH(OH) -> CH3CH(O)}, endothermic
2. Response to temperature: Boltzmann distribution favors higher energy things as $T$ increases
3. Example: ethane dehydrogenation, \ce{C2H6 -> C2H4 + H2}, positive entropy
4. Equilibrium composition starting from \ce{C2H6}, at constant pressure
    \[ K_p(T) = \frac{q_{\ce{C2H4}}^\circ(T) q_{\ce{H2}}^\circ(T)}{q_{\ce{C2H6}}^\circ(T)} e^{-\Delta E(0)/k_BT} =  \frac{P_{\ce{C2H4}}P_{\ce{H2}}}{P_{\ce{C2H6}}}\frac{1}{P^\circ} = \frac{P}{P^\circ}\frac{x^2}{(1-x)(1+x)} \]
5. Response to pressure change: translational DOFs increasingly favor side with fewer molecules as volume decreases/pressure increases

*** Thermodynamic tables
1. General chemical reaction \(\sum_i \nu_i A_i = 0\), \(\nu_i\) stoichiometric coefficients
2. Thermodynamic change \(\Delta W^\circ(T) = \sum_i \nu_i W^\circ_i(T)\), where \(W = A, U, S, G, \ldots \)
3. Tabulations a common source of standard state /H/ and /S/, eg [[http://webbook.nist.gov]]
   1. \(S^\circ(T)\) referenced to \SI{0}{K}, because \(S(0) = 0\) (Third law)
     \[ S^\circ(T^\prime) = S^\circ(T) + \int_T^{T^\prime} \frac{C^\circ_p(T)}{T} dT\]
   2. Enthalpies of elements in their most stable form at \(T=\SI{298}{K}\), \(P=\SI{1}{bar}\) defined to be zero
   3. Enthalpies of substances tabulated as /formation enthalpies/ relative to constiuent elements
       \[ \Delta H^\circ(T) = \sum_i \nu_i \Delta H^\circ_{f,i}(T) \]
       \[ \Delta H^\circ(T^\prime) = \Delta H^\circ(T) + \int_T^{T^\prime} \Delta C^\circ_p(T) dT\]
** Lecture 21: Chemical kinetics
*** Kinetics and reaction rates
1. Rate: number per unit time per unit something
*** Empirical chemical kinetics
1. Rate laws, rate orders, and rate constants
2. Functions of $T$, $P$, composition $C_i$
3. differential vs integrated rate laws
4. Arrhenius expression, $k=A e^{-E_a/k_BT}$
   1. Arrhenius plot, \(\ln k\) vs \(1/T\)
#+CAPTION: Basic kinetic rate laws
|--------------+-------------------+-----------------------------+---------------|
|              | differential rate | integrated rate             | half-life     |
|--------------+-------------------+-----------------------------+---------------|
| First order  | $r = kC_A$        | $C_A = C_{A0} e^{-k \tau}$  | $\ln 2/k$     |
| Second order | $r = kC_A^2$      | $1/C_A = 1/C_{A0} + k \tau$ | $1/kC_{A0}$   |

*** Reaction mechanisms
1. Elementary steps and molecularity
2. Ozone decomposition, rate second-order at high \(P_{\ce{O2}}\), first-order at low \(P_{\ce{O2}}\)
   | \ce{2 O3 -> 3 O2}        |
   |--------------------------|
   | \ce{O3 ->[k_1] O2 + O}   |
   | \ce{O2 + O ->[k_-1] O3}     |
   | \ce{O + O3 ->[k_2] 2 O2} |
3. Collision theory
   1. A + B \rightarrow products
   2. rate proportional to A/B collision frequency $z_{AB}$ weighted by fraction of collisions with energy $> E_a$
      \begin{displaymath}
         r = k C_A C_B , k = \left ( \frac{8 k_B T}{\pi \mu} \right )^{1/2} \sigma_{AB} N_{av} e^{-E_a/k_BT}
      \end{displaymath}
   3. upper bound on real rates
*** Transition state theory (TST)
1. Assumptions
   1. Existence of reaction coordinate (PES)
   2. Existence of dividing surface
   3. Equilibrium between reactants and "transition state"
   4. Harmonic approximation for transition state
2. rate proportional to concentration of "activated complex" over reactants times crossing frequency
   \begin{eqnarray*}
      r & = & k C_AC_B \\
        & = & k^\ddagger C_{AB}^\ddagger \\
        & = & \nu^\ddagger K^\ddagger C_A C_ B \\
        & = & \nu^\ddagger \frac{k_BT}{h\nu^\ddagger}\bar{K}^\ddagger(T) C_A C_B \\
        & = & \frac{k_B T}{h} \frac{q^\ddagger(T)}{q_A(T) q_B(T)}  e^{-{\Delta E(0)/k_BT}} C_A C_B
   \end{eqnarray*}
3. application to atom - atom collision
4. application to two molecules - vinyl alcohol to acetaldehyde
5. microscopic reversibility
6. equilibrium requirement \(K_{eq}(T) = k_f(T)/k_r(T)\)

#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 0.6\textwidth
[[./Images/PES.png]]
*** Locating transition states computationally
*** Thermodynamic connection
1. Relate activated complex equilibrium constant to activation free energy
   \[ \(\bar{K}^\ddagger(T) = e^{-\Delta G^{\circ \ddagger}(T)/kT} = e^{-\Delta H^{\circ \ddagger}(T)/k_BT}e^{\Delta S^{\circ \ddagger}(T)/k_B} \] 
2. Compare to Arrhenius expression 
   \[E_a = \Delta H^{\circ \ddagger}(T) + kT, A = \frac{k_B T}{h}e^1e^{\Delta S^{\circ \ddagger}(T)/k_B}\]

#+BEGIN_SRC python :exports results :results output 
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import fsolve

kB = 8.61733e-5      # eV /K
h = 4.13566766e-15  # eV s
eVtokJ = 96.485332
autoeV= 27.212      # eV
Nav = 6.022e23      # Avogadro's number 
amutoeVc2 = 931494095.17 # convert amu to eV/c^2
R0 = kB * eVtokJ * 1000.       # gas constant in J/mol K
c = 299792458 # m / s

class Molecule(object):
    def __init__(self, name, mass, energy, rot, vib, helmholtz):
        self.name = name
        self.mass = mass
        self.energy = energy
        self.rot = rot
        self.vib = vib
        self.helmholtz = helmholtz

    def Hello(self):
        return "Hello {}".format(self.name)

    def Lambda(self, T):
        m = self.mass * amutoeVc2
        return h/np.sqrt(2*np.pi*m*kB*T)*c

    def qtrans(self,T):  #  mole/m^3
        m = self.mass * amutoeVc2
        l = h/np.sqrt(2*np.pi*m*kB*T)*c
        return (1./Nav)*(1./l)**3

    def qrot(self,T):
        if self.rot[1] > 0:
            return np.sqrt((np.pi*(T/self.rot[0])*(T/self.rot[1])*(T/self.rot[2])))
        else:
            return T/self.rot[0]

    def qvib(self,T):
        qvib = 1
        for mode in self.vib:
            qvib = qvib*(1.-np.exp(-mode/T))**-1
        return qvib

    def qtot(self,T):
        return self.qtrans(T)*self.qrot(T)*self.qvib(T)

    def ZPE(self):
        ZPE=0.
        for mode in self.vib:
            ZPE = ZPE + mode
        return ZPE * (0.5)*kB

    def Utrans(self,T):
        return 1.5*kB*T

    def Urot(self,T):
        return 1.5*kB*T

    def Uvib(self,T):
        Uvib=0.
        for mode in self.vib:
            Uvib=Uvib+kB*(mode/(np.exp(mode/T)-1.0))
        return Uvib

    def Utot(self,T):
        return self.Utrans(T)+self.Urot(T)+self.Uvib(T)

# Fundamental relationships
def A(q):
   return -kB*T*np.log(q)

def S(A,U,T):
   return (U - A)/T

def Delta(nu,A):
    return np.dot(nu,A)

VA = Molecule("Vinyl alcohol", 44., -153.802227784, [3.06869, 0.49808, 0.42852],[342.12,   692.39,  1032.15,  1198.36,  1386.62, 1411.99,  1670.11,  1880.98,  1967.27,  2101.01, 2532.91,  4541.20,  4591.62,  4716.63,  5454.14],[])

Ac = Molecule("Acetaldehyde", 44., -153.830119460, [2.72923, 0.48351, 0.43371], [222.94,  729.92,  1121.87,  1285.63,  1636.17, 1646.79,  2018.97,  2080.76, 2143.85,  2157.44,  2651.18,  4169.12,  4379.22,  4459.71,  4553.14],[])

TS = Molecule("TS", 44., -153.714172988, [2.33148, 0.58652, 0.48832], [857.94,   939.84,  1148.55,  1395.88,  1536.40, 1678.69,  1744.34,  1877.98,  2155.56,  2261.86, 2665.34,  4471.92,  4522.04,  4596.48], [])

T = np.linspace(600,1500,500)

#
# Ethane dehydrogenation at 1 bar
#
stdconc = (1e5/(R0*T)) # (1 bar/ R T) = mol/m3

Ea0 = (TS.energy-VA.energy)*autoeV + (TS.ZPE() - VA.ZPE())

print('Vinyl alcohol to TS {:4.0f} kJ/mol'.format(Ea0*eVtokJ))

kTh = (kB/h) * T 
qratio = (TS.qtot(T)/VA.qtot(T))
Exp = np.exp(-Ea0/(kB*T))
k  = kTh * qratio * Exp

thalf = np.log(2)/k

plt.figure()
plt.plot(T,kTh,label="kB T/h")
plt.xlabel("Temperature (K)")
plt.ylabel("1/s")
plt.legend()
plt.savefig("./Images/kTh.png")

plt.figure()
plt.title("q TS/q vinyl acetate")
plt.plot(T,qratio,label="qratio")
plt.xlabel("Temperature (K)")
plt.legend()
plt.savefig("./Images/qratio.png")

plt.figure()
plt.title("Exp(-Ea(0)/kT")
plt.plot(T,Exp,label="exp(-Ea/kT")
plt.xlabel("Temperature (K)")
plt.legend()
plt.savefig("./Images/expEa.png")

plt.figure()
plt.title("Half life")
plt.plot(T,thalf,label="half life")
plt.xlabel("Temperature (K)")
plt.ylabel("s")
plt.legend()
plt.savefig("./Images/halflife.png")

plt.figure()
plt.title("Arrhenius plot")
plt.plot(1./T,np.log(k),label="ln(k)")
plt.xlabel("1/Temperature (1/K)")
plt.ylabel("s")
plt.legend()
plt.savefig("./Images/arrhenius.png")


deltaUd = TS.Utot(T) - VA.Utot(T)
deltaHd = deltaUd + kB*T

deltaAd = A(TS.qtot(T)) - A(VA.qtot(T))
deltaSd = S(deltaAd,deltaUd,T)

#+END_SRC

#+RESULTS:
: Vinyl alcohol to TS  216 kJ/mol

#+BEGIN_EXPORT latex
\begin{table}
   \caption{Vinyl alcohol to acetaldehyde}
\begin{tabular}{cc}
\includegraphics[scale=0.5]{./Images/kTh.png} & \includegraphics[scale=0.5]{./Images/qratio.png} \\ \includegraphics[scale=0.5]{./Images/expEa.png} & \includegraphics[scale=0.5]{./Images/halflife.png} \\
\includegraphics[scale=0.5]{./Images/arrhenius.png} & 
\includegraphics[scale=0.3]{./Images/VA-TS/Path.png} 
\end{tabular}
\end{table}
#+END_EXPORT

*** Application: gas-phase reactions
1. Vinyl alcohol to acetaldehyde
2. Ethane pyrolysis, \ce{C2H6 -> C2H4 + H2}, [[https://pubs.acs.org/doi/10.1021/jp206503d][doi:10.1021/jp206503d]]
*** Heterogeneous reactions and catalysis
1. molecule-surface collisions
2. surface reactions
3. Ammonia oxidation, \ce{NH3 + O2 -> NO + N2 + N2O}, [[http://pubs.acs.org/doi/10.1021/acscatal.8b04251][doi:10.1021/acscatal.8b04251]] 

#+BEGIN_EXPORT latex
\begin{table}
   \caption{DFT PES for ethylene dissociation on Ni2P}
\begin{tabular}{cc}
\includegraphics[scale=0.33]{./Images/ethylene-001.png} & \includegraphics[scale=0.33]{./Images/ethylene-002.png} \\ \includegraphics[scale=0.33]{./Images/ethylene-003.png} & \includegraphics[scale=0.33]{./Images/ethylene-004.png} \\
\includegraphics[scale=0.33]{./Images/ethylene-005.png} & 
\includegraphics[scale=0.18]{./Images/ethylene-pes-animation.png} 
\end{tabular}
\end{table}
#+END_EXPORT

[[./Images/TS-Ethylene.gif]]
*** Diffusion-controlled reactions
1. Intermediate complex
2. Steady-state approximation
3. Diffusion-controlled limit ($k_D = 4\pi (r_A + r_B) D_{AB}$)
4. Reaction-controlled limit ($k_{app}=(k_D/k_{-D})k_r$)

#+BEGIN_EXPORT latex
\begin{table}
\begin{center}
    \caption{\large{Equilibrium and Rate Constants}}
   \begin{description}
   \item[Equilibrium Constants] $a~\text{A} + b~\text{B} \rightleftharpoons c~\text{C} + d~\text{D} $
     \begin{eqnarray*}
       K_{eq}(T) &=& e^{\Delta S^\circ(T)/k_B}e^{-\Delta H^\circ(T)/k_BT}
       \\ \\
            K_c(T) &=&
          \left(\frac{1}{c^\circ}\right)^{\nu_c+\nu_d-\nu_a-\nu_b}\frac{(q_c/V)^{\nu_c}(q_d/V)^{\nu_d}}{(q_a/V)^{\nu_a}(q_b/V)^{\nu_b}}e^{-\Delta
            E(0)\beta}\\ \\
            K_p(T) &=&
          \left(\frac{k_BT}{P^\circ}\right)^{\nu_c+\nu_d-\nu_a-\nu_b}\frac{(q_c/V)^{\nu_c}(q_d/V)^{\nu_d}}{(q_a/V)^{\nu_a}(q_b/V)^{\nu_b}}e^{-\Delta
            E(0)\beta}
\end{eqnarray*}
\item[Unimolecular Reaction] $\text[A] \rightleftharpoons [\text{A} ]^\ddagger
  \rightarrow C$
      \begin{displaymath}
        k(T)=\nu^\ddagger \bar K^\ddagger=\frac{k_B T}{h} \frac{\bar{q}_\ddagger(T)/V}{q_A(T)/V}
          e^{-\Delta E^\ddagger(0)\beta}
      \end{displaymath}
\begin{center}
      \begin{tabular}{cc}
      $ \displaystyle E_a =\Delta H^{\circ\ddagger}+k_B T $
      & $ \displaystyle A = e^1\frac{k_B T}{h} e^{\Delta S^{\circ\ddagger}} $
      \end{tabular}
\end{center}
\item[Bimolecular Reaction] $
        \mathrm{A} + \mathrm{B} \rightleftharpoons [ \mathrm{AB}]^\ddagger
        \rightarrow \text{C}$
      \begin{displaymath}
        k(T)=\nu^\ddagger \bar K^\ddagger=\frac{k_B T}{h} \frac{q_\ddagger(T)/V}{(q_A(T)/V)(q_B(T)/V)}\left
          (\frac{1}{c^\circ}\right )^{-1}
        e^{-\Delta E^\ddagger(0)\beta}
      \end{displaymath}
      \begin{center}
        \begin{tabular}{cc}
        $ \displaystyle E_a  =\Delta H^{\circ\ddagger}+2 k_B T $ & $ \displaystyle
        A  = e^2\frac{k_B T}{h} e^{\Delta S^{\circ\ddagger}} $
      \end{tabular}
      \end{center}
   \end{description}
 \end{center}
 \end{table}
#+END_EXPORT

** Lecture 22: Conclusion
1. Do you think about the burning lighter any differently now?
